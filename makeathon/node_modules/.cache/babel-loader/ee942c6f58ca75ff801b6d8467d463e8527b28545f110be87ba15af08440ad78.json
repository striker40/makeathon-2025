{"ast":null,"code":"/**\r\n * @import {Schema} from 'property-information'\r\n */\n\nimport { DefinedInfo } from './util/defined-info.js';\nimport { Info } from './util/info.js';\nimport { normalize } from './normalize.js';\nconst cap = /[A-Z]/g;\nconst dash = /-[a-z]/g;\nconst valid = /^data[-\\w.:]+$/i;\n\n/**\r\n * Look up info on a property.\r\n *\r\n * In most cases the given `schema` contains info on the property.\r\n * All standard,\r\n * most legacy,\r\n * and some non-standard properties are supported.\r\n * For these cases,\r\n * the returned `Info` has hints about the value of the property.\r\n *\r\n * `name` can also be a valid data attribute or property,\r\n * in which case an `Info` object with the correctly cased `attribute` and\r\n * `property` is returned.\r\n *\r\n * `name` can be an unknown attribute,\r\n * in which case an `Info` object with `attribute` and `property` set to the\r\n * given name is returned.\r\n * It is not recommended to provide unsupported legacy or recently specced\r\n * properties.\r\n *\r\n *\r\n * @param {Schema} schema\r\n *   Schema;\r\n *   either the `html` or `svg` export.\r\n * @param {string} value\r\n *   An attribute-like or property-like name;\r\n *   it will be passed through `normalize` to hopefully find the correct info.\r\n * @returns {Info}\r\n *   Info.\r\n */\nexport function find(schema, value) {\n  const normal = normalize(value);\n  let property = value;\n  let Type = Info;\n  if (normal in schema.normal) {\n    return schema.property[schema.normal[normal]];\n  }\n  if (normal.length > 4 && normal.slice(0, 4) === 'data' && valid.test(value)) {\n    // Attribute or property.\n    if (value.charAt(4) === '-') {\n      // Turn it into a property.\n      const rest = value.slice(5).replace(dash, camelcase);\n      property = 'data' + rest.charAt(0).toUpperCase() + rest.slice(1);\n    } else {\n      // Turn it into an attribute.\n      const rest = value.slice(4);\n      if (!dash.test(rest)) {\n        let dashes = rest.replace(cap, kebab);\n        if (dashes.charAt(0) !== '-') {\n          dashes = '-' + dashes;\n        }\n        value = 'data' + dashes;\n      }\n    }\n    Type = DefinedInfo;\n  }\n  return new Type(property, value);\n}\n\n/**\r\n * @param {string} $0\r\n *   Value.\r\n * @returns {string}\r\n *   Kebab.\r\n */\nfunction kebab($0) {\n  return '-' + $0.toLowerCase();\n}\n\n/**\r\n * @param {string} $0\r\n *   Value.\r\n * @returns {string}\r\n *   Camel.\r\n */\nfunction camelcase($0) {\n  return $0.charAt(1).toUpperCase();\n}","map":{"version":3,"names":["DefinedInfo","Info","normalize","cap","dash","valid","find","schema","value","normal","property","Type","length","slice","test","charAt","rest","replace","camelcase","toUpperCase","dashes","kebab","$0","toLowerCase"],"sources":["C:/Users/smart/Downloads/Final Project P20119/makeathon-2025/makeathon/node_modules/property-information/lib/find.js"],"sourcesContent":["/**\r\n * @import {Schema} from 'property-information'\r\n */\r\n\r\nimport {DefinedInfo} from './util/defined-info.js'\r\nimport {Info} from './util/info.js'\r\nimport {normalize} from './normalize.js'\r\n\r\nconst cap = /[A-Z]/g\r\nconst dash = /-[a-z]/g\r\nconst valid = /^data[-\\w.:]+$/i\r\n\r\n/**\r\n * Look up info on a property.\r\n *\r\n * In most cases the given `schema` contains info on the property.\r\n * All standard,\r\n * most legacy,\r\n * and some non-standard properties are supported.\r\n * For these cases,\r\n * the returned `Info` has hints about the value of the property.\r\n *\r\n * `name` can also be a valid data attribute or property,\r\n * in which case an `Info` object with the correctly cased `attribute` and\r\n * `property` is returned.\r\n *\r\n * `name` can be an unknown attribute,\r\n * in which case an `Info` object with `attribute` and `property` set to the\r\n * given name is returned.\r\n * It is not recommended to provide unsupported legacy or recently specced\r\n * properties.\r\n *\r\n *\r\n * @param {Schema} schema\r\n *   Schema;\r\n *   either the `html` or `svg` export.\r\n * @param {string} value\r\n *   An attribute-like or property-like name;\r\n *   it will be passed through `normalize` to hopefully find the correct info.\r\n * @returns {Info}\r\n *   Info.\r\n */\r\nexport function find(schema, value) {\r\n  const normal = normalize(value)\r\n  let property = value\r\n  let Type = Info\r\n\r\n  if (normal in schema.normal) {\r\n    return schema.property[schema.normal[normal]]\r\n  }\r\n\r\n  if (normal.length > 4 && normal.slice(0, 4) === 'data' && valid.test(value)) {\r\n    // Attribute or property.\r\n    if (value.charAt(4) === '-') {\r\n      // Turn it into a property.\r\n      const rest = value.slice(5).replace(dash, camelcase)\r\n      property = 'data' + rest.charAt(0).toUpperCase() + rest.slice(1)\r\n    } else {\r\n      // Turn it into an attribute.\r\n      const rest = value.slice(4)\r\n\r\n      if (!dash.test(rest)) {\r\n        let dashes = rest.replace(cap, kebab)\r\n\r\n        if (dashes.charAt(0) !== '-') {\r\n          dashes = '-' + dashes\r\n        }\r\n\r\n        value = 'data' + dashes\r\n      }\r\n    }\r\n\r\n    Type = DefinedInfo\r\n  }\r\n\r\n  return new Type(property, value)\r\n}\r\n\r\n/**\r\n * @param {string} $0\r\n *   Value.\r\n * @returns {string}\r\n *   Kebab.\r\n */\r\nfunction kebab($0) {\r\n  return '-' + $0.toLowerCase()\r\n}\r\n\r\n/**\r\n * @param {string} $0\r\n *   Value.\r\n * @returns {string}\r\n *   Camel.\r\n */\r\nfunction camelcase($0) {\r\n  return $0.charAt(1).toUpperCase()\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;;AAEA,SAAQA,WAAW,QAAO,wBAAwB;AAClD,SAAQC,IAAI,QAAO,gBAAgB;AACnC,SAAQC,SAAS,QAAO,gBAAgB;AAExC,MAAMC,GAAG,GAAG,QAAQ;AACpB,MAAMC,IAAI,GAAG,SAAS;AACtB,MAAMC,KAAK,GAAG,iBAAiB;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,IAAIA,CAACC,MAAM,EAAEC,KAAK,EAAE;EAClC,MAAMC,MAAM,GAAGP,SAAS,CAACM,KAAK,CAAC;EAC/B,IAAIE,QAAQ,GAAGF,KAAK;EACpB,IAAIG,IAAI,GAAGV,IAAI;EAEf,IAAIQ,MAAM,IAAIF,MAAM,CAACE,MAAM,EAAE;IAC3B,OAAOF,MAAM,CAACG,QAAQ,CAACH,MAAM,CAACE,MAAM,CAACA,MAAM,CAAC,CAAC;EAC/C;EAEA,IAAIA,MAAM,CAACG,MAAM,GAAG,CAAC,IAAIH,MAAM,CAACI,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,MAAM,IAAIR,KAAK,CAACS,IAAI,CAACN,KAAK,CAAC,EAAE;IAC3E;IACA,IAAIA,KAAK,CAACO,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;MAC3B;MACA,MAAMC,IAAI,GAAGR,KAAK,CAACK,KAAK,CAAC,CAAC,CAAC,CAACI,OAAO,CAACb,IAAI,EAAEc,SAAS,CAAC;MACpDR,QAAQ,GAAG,MAAM,GAAGM,IAAI,CAACD,MAAM,CAAC,CAAC,CAAC,CAACI,WAAW,CAAC,CAAC,GAAGH,IAAI,CAACH,KAAK,CAAC,CAAC,CAAC;IAClE,CAAC,MAAM;MACL;MACA,MAAMG,IAAI,GAAGR,KAAK,CAACK,KAAK,CAAC,CAAC,CAAC;MAE3B,IAAI,CAACT,IAAI,CAACU,IAAI,CAACE,IAAI,CAAC,EAAE;QACpB,IAAII,MAAM,GAAGJ,IAAI,CAACC,OAAO,CAACd,GAAG,EAAEkB,KAAK,CAAC;QAErC,IAAID,MAAM,CAACL,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;UAC5BK,MAAM,GAAG,GAAG,GAAGA,MAAM;QACvB;QAEAZ,KAAK,GAAG,MAAM,GAAGY,MAAM;MACzB;IACF;IAEAT,IAAI,GAAGX,WAAW;EACpB;EAEA,OAAO,IAAIW,IAAI,CAACD,QAAQ,EAAEF,KAAK,CAAC;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASa,KAAKA,CAACC,EAAE,EAAE;EACjB,OAAO,GAAG,GAAGA,EAAE,CAACC,WAAW,CAAC,CAAC;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASL,SAASA,CAACI,EAAE,EAAE;EACrB,OAAOA,EAAE,CAACP,MAAM,CAAC,CAAC,CAAC,CAACI,WAAW,CAAC,CAAC;AACnC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}