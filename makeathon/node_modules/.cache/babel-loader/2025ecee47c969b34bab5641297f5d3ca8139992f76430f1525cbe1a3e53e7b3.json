{"ast":null,"code":"export const xmlReplacer = /[\"$&'<>\\u0080-\\uFFFF]/g;\nconst xmlCodeMap = new Map([[34, \"&quot;\"], [38, \"&amp;\"], [39, \"&apos;\"], [60, \"&lt;\"], [62, \"&gt;\"]]);\n// For compatibility with node < 4, we wrap `codePointAt`\nexport const getCodePoint =\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt == null ? (c, index) => (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index) :\n// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n(input, index) => input.codePointAt(index);\n/**\r\n * Encodes all non-ASCII characters, as well as characters not valid in XML\r\n * documents using XML entities.\r\n *\r\n * If a character has no equivalent entity, a\r\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\r\n */\nexport function encodeXML(input) {\n  let returnValue = \"\";\n  let lastIndex = 0;\n  let match;\n  while ((match = xmlReplacer.exec(input)) !== null) {\n    const {\n      index\n    } = match;\n    const char = input.charCodeAt(index);\n    const next = xmlCodeMap.get(char);\n    if (next === undefined) {\n      returnValue += `${input.substring(lastIndex, index)}&#x${getCodePoint(input, index).toString(16)};`;\n      // Increase by 1 if we have a surrogate pair\n      lastIndex = xmlReplacer.lastIndex += Number((char & 64512) === 55296);\n    } else {\n      returnValue += input.substring(lastIndex, index) + next;\n      lastIndex = index + 1;\n    }\n  }\n  return returnValue + input.substr(lastIndex);\n}\n/**\r\n * Encodes all non-ASCII characters, as well as characters not valid in XML\r\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\r\n *\r\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\r\n * of reduced transportability.\r\n *\r\n * @param data String to escape.\r\n */\nexport const escape = encodeXML;\n/**\r\n * Creates a function that escapes all characters matched by the given regular\r\n * expression using the given map of characters to escape to their entities.\r\n *\r\n * @param regex Regular expression to match characters to escape.\r\n * @param map Map of characters to escape to their entities.\r\n *\r\n * @returns Function that escapes all characters matched by the given regular\r\n * expression using the given map of characters to escape to their entities.\r\n */\nfunction getEscaper(regex, map) {\n  return function escape(data) {\n    let match;\n    let lastIndex = 0;\n    let result = \"\";\n    while (match = regex.exec(data)) {\n      if (lastIndex !== match.index) {\n        result += data.substring(lastIndex, match.index);\n      }\n      // We know that this character will be in the map.\n      result += map.get(match[0].charCodeAt(0));\n      // Every match will be of length 1\n      lastIndex = match.index + 1;\n    }\n    return result + data.substring(lastIndex);\n  };\n}\n/**\r\n * Encodes all characters not valid in XML documents using XML entities.\r\n *\r\n * Note that the output will be character-set dependent.\r\n *\r\n * @param data String to escape.\r\n */\nexport const escapeUTF8 = /* #__PURE__ */getEscaper(/[\"&'<>]/g, xmlCodeMap);\n/**\r\n * Encodes all characters that have to be escaped in HTML attributes,\r\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\r\n *\r\n * @param data String to escape.\r\n */\nexport const escapeAttribute = /* #__PURE__ */getEscaper(/[\"&\\u00A0]/g, new Map([[34, \"&quot;\"], [38, \"&amp;\"], [160, \"&nbsp;\"]]));\n/**\r\n * Encodes all characters that have to be escaped in HTML text,\r\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\r\n *\r\n * @param data String to escape.\r\n */\nexport const escapeText = /* #__PURE__ */getEscaper(/[&<>\\u00A0]/g, new Map([[38, \"&amp;\"], [60, \"&lt;\"], [62, \"&gt;\"], [160, \"&nbsp;\"]]));","map":{"version":3,"names":["xmlReplacer","xmlCodeMap","Map","getCodePoint","String","prototype","codePointAt","c","index","charCodeAt","input","encodeXML","returnValue","lastIndex","match","exec","char","next","get","undefined","substring","toString","Number","substr","escape","getEscaper","regex","map","data","result","escapeUTF8","escapeAttribute","escapeText"],"sources":["C:\\Users\\smart\\Downloads\\Final Project P20119\\makeathon-2025\\makeathon\\node_modules\\hast-util-raw\\node_modules\\entities\\src\\escape.ts"],"sourcesContent":["export const xmlReplacer: RegExp = /[\"$&'<>\\u0080-\\uFFFF]/g;\r\n\r\nconst xmlCodeMap = new Map([\r\n    [34, \"&quot;\"],\r\n    [38, \"&amp;\"],\r\n    [39, \"&apos;\"],\r\n    [60, \"&lt;\"],\r\n    [62, \"&gt;\"],\r\n]);\r\n\r\n// For compatibility with node < 4, we wrap `codePointAt`\r\nexport const getCodePoint: (c: string, index: number) => number =\r\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\r\n    String.prototype.codePointAt == null\r\n        ? (c: string, index: number): number =>\r\n              (c.charCodeAt(index) & 0xfc_00) === 0xd8_00\r\n                  ? (c.charCodeAt(index) - 0xd8_00) * 0x4_00 +\r\n                    c.charCodeAt(index + 1) -\r\n                    0xdc_00 +\r\n                    0x1_00_00\r\n                  : c.charCodeAt(index)\r\n        : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\r\n          (input: string, index: number): number => input.codePointAt(index)!;\r\n\r\n/**\r\n * Encodes all non-ASCII characters, as well as characters not valid in XML\r\n * documents using XML entities.\r\n *\r\n * If a character has no equivalent entity, a\r\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\r\n */\r\nexport function encodeXML(input: string): string {\r\n    let returnValue = \"\";\r\n    let lastIndex = 0;\r\n    let match;\r\n\r\n    while ((match = xmlReplacer.exec(input)) !== null) {\r\n        const { index } = match;\r\n        const char = input.charCodeAt(index);\r\n        const next = xmlCodeMap.get(char);\r\n\r\n        if (next === undefined) {\r\n            returnValue += `${input.substring(lastIndex, index)}&#x${getCodePoint(\r\n                input,\r\n                index,\r\n            ).toString(16)};`;\r\n            // Increase by 1 if we have a surrogate pair\r\n            lastIndex = xmlReplacer.lastIndex += Number(\r\n                (char & 0xfc_00) === 0xd8_00,\r\n            );\r\n        } else {\r\n            returnValue += input.substring(lastIndex, index) + next;\r\n            lastIndex = index + 1;\r\n        }\r\n    }\r\n\r\n    return returnValue + input.substr(lastIndex);\r\n}\r\n\r\n/**\r\n * Encodes all non-ASCII characters, as well as characters not valid in XML\r\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\r\n *\r\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\r\n * of reduced transportability.\r\n *\r\n * @param data String to escape.\r\n */\r\nexport const escape: typeof encodeXML = encodeXML;\r\n\r\n/**\r\n * Creates a function that escapes all characters matched by the given regular\r\n * expression using the given map of characters to escape to their entities.\r\n *\r\n * @param regex Regular expression to match characters to escape.\r\n * @param map Map of characters to escape to their entities.\r\n *\r\n * @returns Function that escapes all characters matched by the given regular\r\n * expression using the given map of characters to escape to their entities.\r\n */\r\nfunction getEscaper(\r\n    regex: RegExp,\r\n    map: Map<number, string>,\r\n): (data: string) => string {\r\n    return function escape(data: string): string {\r\n        let match;\r\n        let lastIndex = 0;\r\n        let result = \"\";\r\n\r\n        while ((match = regex.exec(data))) {\r\n            if (lastIndex !== match.index) {\r\n                result += data.substring(lastIndex, match.index);\r\n            }\r\n\r\n            // We know that this character will be in the map.\r\n            result += map.get(match[0].charCodeAt(0))!;\r\n\r\n            // Every match will be of length 1\r\n            lastIndex = match.index + 1;\r\n        }\r\n\r\n        return result + data.substring(lastIndex);\r\n    };\r\n}\r\n\r\n/**\r\n * Encodes all characters not valid in XML documents using XML entities.\r\n *\r\n * Note that the output will be character-set dependent.\r\n *\r\n * @param data String to escape.\r\n */\r\nexport const escapeUTF8: (data: string) => string = /* #__PURE__ */ getEscaper(\r\n    /[\"&'<>]/g,\r\n    xmlCodeMap,\r\n);\r\n\r\n/**\r\n * Encodes all characters that have to be escaped in HTML attributes,\r\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\r\n *\r\n * @param data String to escape.\r\n */\r\nexport const escapeAttribute: (data: string) => string =\r\n    /* #__PURE__ */ getEscaper(\r\n        /[\"&\\u00A0]/g,\r\n        new Map([\r\n            [34, \"&quot;\"],\r\n            [38, \"&amp;\"],\r\n            [160, \"&nbsp;\"],\r\n        ]),\r\n    );\r\n\r\n/**\r\n * Encodes all characters that have to be escaped in HTML text,\r\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\r\n *\r\n * @param data String to escape.\r\n */\r\nexport const escapeText: (data: string) => string = /* #__PURE__ */ getEscaper(\r\n    /[&<>\\u00A0]/g,\r\n    new Map([\r\n        [38, \"&amp;\"],\r\n        [60, \"&lt;\"],\r\n        [62, \"&gt;\"],\r\n        [160, \"&nbsp;\"],\r\n    ]),\r\n);\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}