{"ast":null,"code":"/**\r\n * @typedef {import('hast').Element} Element\r\n * @typedef {import('hast').Parents} Parents\r\n */\n\n/**\r\n * @template Fn\r\n * @template Fallback\r\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\r\n */\n\n/**\r\n * @callback Check\r\n *   Check that an arbitrary value is an element.\r\n * @param {unknown} this\r\n *   Context object (`this`) to call `test` with\r\n * @param {unknown} [element]\r\n *   Anything (typically a node).\r\n * @param {number | null | undefined} [index]\r\n *   Position of `element` in its parent.\r\n * @param {Parents | null | undefined} [parent]\r\n *   Parent of `element`.\r\n * @returns {boolean}\r\n *   Whether this is an element and passes a test.\r\n *\r\n * @typedef {Array<TestFunction | string> | TestFunction | string | null | undefined} Test\r\n *   Check for an arbitrary element.\r\n *\r\n *   * when `string`, checks that the element has that tag name\r\n *   * when `function`, see `TestFunction`\r\n *   * when `Array`, checks if one of the subtests pass\r\n *\r\n * @callback TestFunction\r\n *   Check if an element passes a test.\r\n * @param {unknown} this\r\n *   The given context.\r\n * @param {Element} element\r\n *   An element.\r\n * @param {number | undefined} [index]\r\n *   Position of `element` in its parent.\r\n * @param {Parents | undefined} [parent]\r\n *   Parent of `element`.\r\n * @returns {boolean | undefined | void}\r\n *   Whether this element passes the test.\r\n *\r\n *   Note: `void` is included until TS sees no return as `undefined`.\r\n */\n\n/**\r\n * Check if `element` is an `Element` and whether it passes the given test.\r\n *\r\n * @param element\r\n *   Thing to check, typically `element`.\r\n * @param test\r\n *   Check for a specific element.\r\n * @param index\r\n *   Position of `element` in its parent.\r\n * @param parent\r\n *   Parent of `element`.\r\n * @param context\r\n *   Context object (`this`) to call `test` with.\r\n * @returns\r\n *   Whether `element` is an `Element` and passes a test.\r\n * @throws\r\n *   When an incorrect `test`, `index`, or `parent` is given; there is no error\r\n *   thrown when `element` is not a node or not an element.\r\n */\nexport const isElement =\n// Note: overloads in JSDoc can’t yet use different `@template`s.\n/**\r\n * @type {(\r\n *   (<Condition extends TestFunction>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &\r\n *   (<Condition extends string>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &\r\n *   ((element?: null | undefined) => false) &\r\n *   ((element: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &\r\n *   ((element: unknown, test?: Test, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => boolean)\r\n * )}\r\n */\n\n/**\r\n * @param {unknown} [element]\r\n * @param {Test | undefined} [test]\r\n * @param {number | null | undefined} [index]\r\n * @param {Parents | null | undefined} [parent]\r\n * @param {unknown} [context]\r\n * @returns {boolean}\r\n */\n// eslint-disable-next-line max-params\nfunction (element, test, index, parent, context) {\n  const check = convertElement(test);\n  if (index !== null && index !== undefined && (typeof index !== 'number' || index < 0 || index === Number.POSITIVE_INFINITY)) {\n    throw new Error('Expected positive finite `index`');\n  }\n  if (parent !== null && parent !== undefined && (!parent.type || !parent.children)) {\n    throw new Error('Expected valid `parent`');\n  }\n  if ((index === null || index === undefined) !== (parent === null || parent === undefined)) {\n    throw new Error('Expected both `index` and `parent`');\n  }\n  return looksLikeAnElement(element) ? check.call(context, element, index, parent) : false;\n};\n\n/**\r\n * Generate a check from a test.\r\n *\r\n * Useful if you’re going to test many nodes, for example when creating a\r\n * utility where something else passes a compatible test.\r\n *\r\n * The created function is a bit faster because it expects valid input only:\r\n * an `element`, `index`, and `parent`.\r\n *\r\n * @param test\r\n *   A test for a specific element.\r\n * @returns\r\n *   A check.\r\n */\nexport const convertElement =\n// Note: overloads in JSDoc can’t yet use different `@template`s.\n/**\r\n * @type {(\r\n *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &\r\n *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &\r\n *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &\r\n *   ((test?: Test) => Check)\r\n * )}\r\n */\n\n/**\r\n * @param {Test | null | undefined} [test]\r\n * @returns {Check}\r\n */\nfunction (test) {\n  if (test === null || test === undefined) {\n    return element;\n  }\n  if (typeof test === 'string') {\n    return tagNameFactory(test);\n  }\n\n  // Assume array.\n  if (typeof test === 'object') {\n    return anyFactory(test);\n  }\n  if (typeof test === 'function') {\n    return castFactory(test);\n  }\n  throw new Error('Expected function, string, or array as `test`');\n};\n\n/**\r\n * Handle multiple tests.\r\n *\r\n * @param {Array<TestFunction | string>} tests\r\n * @returns {Check}\r\n */\nfunction anyFactory(tests) {\n  /** @type {Array<Check>} */\n  const checks = [];\n  let index = -1;\n  while (++index < tests.length) {\n    checks[index] = convertElement(tests[index]);\n  }\n  return castFactory(any);\n\n  /**\r\n   * @this {unknown}\r\n   * @type {TestFunction}\r\n   */\n  function any(...parameters) {\n    let index = -1;\n    while (++index < checks.length) {\n      if (checks[index].apply(this, parameters)) return true;\n    }\n    return false;\n  }\n}\n\n/**\r\n * Turn a string into a test for an element with a certain type.\r\n *\r\n * @param {string} check\r\n * @returns {Check}\r\n */\nfunction tagNameFactory(check) {\n  return castFactory(tagName);\n\n  /**\r\n   * @param {Element} element\r\n   * @returns {boolean}\r\n   */\n  function tagName(element) {\n    return element.tagName === check;\n  }\n}\n\n/**\r\n * Turn a custom test into a test for an element that passes that test.\r\n *\r\n * @param {TestFunction} testFunction\r\n * @returns {Check}\r\n */\nfunction castFactory(testFunction) {\n  return check;\n\n  /**\r\n   * @this {unknown}\r\n   * @type {Check}\r\n   */\n  function check(value, index, parent) {\n    return Boolean(looksLikeAnElement(value) && testFunction.call(this, value, typeof index === 'number' ? index : undefined, parent || undefined));\n  }\n}\n\n/**\r\n * Make sure something is an element.\r\n *\r\n * @param {unknown} element\r\n * @returns {element is Element}\r\n */\nfunction element(element) {\n  return Boolean(element && typeof element === 'object' && 'type' in element && element.type === 'element' && 'tagName' in element && typeof element.tagName === 'string');\n}\n\n/**\r\n * @param {unknown} value\r\n * @returns {value is Element}\r\n */\nfunction looksLikeAnElement(value) {\n  return value !== null && typeof value === 'object' && 'type' in value && 'tagName' in value;\n}","map":{"version":3,"names":["isElement","element","test","index","parent","context","check","convertElement","undefined","Number","POSITIVE_INFINITY","Error","type","children","looksLikeAnElement","call","tagNameFactory","anyFactory","castFactory","tests","checks","length","any","parameters","apply","tagName","testFunction","value","Boolean"],"sources":["C:/Users/smart/Downloads/Final Project P20119/makeathon-2025/makeathon/node_modules/hast-util-is-element/lib/index.js"],"sourcesContent":["/**\r\n * @typedef {import('hast').Element} Element\r\n * @typedef {import('hast').Parents} Parents\r\n */\r\n\r\n/**\r\n * @template Fn\r\n * @template Fallback\r\n * @typedef {Fn extends (value: any) => value is infer Thing ? Thing : Fallback} Predicate\r\n */\r\n\r\n/**\r\n * @callback Check\r\n *   Check that an arbitrary value is an element.\r\n * @param {unknown} this\r\n *   Context object (`this`) to call `test` with\r\n * @param {unknown} [element]\r\n *   Anything (typically a node).\r\n * @param {number | null | undefined} [index]\r\n *   Position of `element` in its parent.\r\n * @param {Parents | null | undefined} [parent]\r\n *   Parent of `element`.\r\n * @returns {boolean}\r\n *   Whether this is an element and passes a test.\r\n *\r\n * @typedef {Array<TestFunction | string> | TestFunction | string | null | undefined} Test\r\n *   Check for an arbitrary element.\r\n *\r\n *   * when `string`, checks that the element has that tag name\r\n *   * when `function`, see `TestFunction`\r\n *   * when `Array`, checks if one of the subtests pass\r\n *\r\n * @callback TestFunction\r\n *   Check if an element passes a test.\r\n * @param {unknown} this\r\n *   The given context.\r\n * @param {Element} element\r\n *   An element.\r\n * @param {number | undefined} [index]\r\n *   Position of `element` in its parent.\r\n * @param {Parents | undefined} [parent]\r\n *   Parent of `element`.\r\n * @returns {boolean | undefined | void}\r\n *   Whether this element passes the test.\r\n *\r\n *   Note: `void` is included until TS sees no return as `undefined`.\r\n */\r\n\r\n/**\r\n * Check if `element` is an `Element` and whether it passes the given test.\r\n *\r\n * @param element\r\n *   Thing to check, typically `element`.\r\n * @param test\r\n *   Check for a specific element.\r\n * @param index\r\n *   Position of `element` in its parent.\r\n * @param parent\r\n *   Parent of `element`.\r\n * @param context\r\n *   Context object (`this`) to call `test` with.\r\n * @returns\r\n *   Whether `element` is an `Element` and passes a test.\r\n * @throws\r\n *   When an incorrect `test`, `index`, or `parent` is given; there is no error\r\n *   thrown when `element` is not a node or not an element.\r\n */\r\nexport const isElement =\r\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\r\n  /**\r\n   * @type {(\r\n   *   (<Condition extends TestFunction>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &\r\n   *   (<Condition extends string>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &\r\n   *   ((element?: null | undefined) => false) &\r\n   *   ((element: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &\r\n   *   ((element: unknown, test?: Test, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => boolean)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * @param {unknown} [element]\r\n     * @param {Test | undefined} [test]\r\n     * @param {number | null | undefined} [index]\r\n     * @param {Parents | null | undefined} [parent]\r\n     * @param {unknown} [context]\r\n     * @returns {boolean}\r\n     */\r\n    // eslint-disable-next-line max-params\r\n    function (element, test, index, parent, context) {\r\n      const check = convertElement(test)\r\n\r\n      if (\r\n        index !== null &&\r\n        index !== undefined &&\r\n        (typeof index !== 'number' ||\r\n          index < 0 ||\r\n          index === Number.POSITIVE_INFINITY)\r\n      ) {\r\n        throw new Error('Expected positive finite `index`')\r\n      }\r\n\r\n      if (\r\n        parent !== null &&\r\n        parent !== undefined &&\r\n        (!parent.type || !parent.children)\r\n      ) {\r\n        throw new Error('Expected valid `parent`')\r\n      }\r\n\r\n      if (\r\n        (index === null || index === undefined) !==\r\n        (parent === null || parent === undefined)\r\n      ) {\r\n        throw new Error('Expected both `index` and `parent`')\r\n      }\r\n\r\n      return looksLikeAnElement(element)\r\n        ? check.call(context, element, index, parent)\r\n        : false\r\n    }\r\n  )\r\n\r\n/**\r\n * Generate a check from a test.\r\n *\r\n * Useful if you’re going to test many nodes, for example when creating a\r\n * utility where something else passes a compatible test.\r\n *\r\n * The created function is a bit faster because it expects valid input only:\r\n * an `element`, `index`, and `parent`.\r\n *\r\n * @param test\r\n *   A test for a specific element.\r\n * @returns\r\n *   A check.\r\n */\r\nexport const convertElement =\r\n  // Note: overloads in JSDoc can’t yet use different `@template`s.\r\n  /**\r\n   * @type {(\r\n   *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &\r\n   *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &\r\n   *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &\r\n   *   ((test?: Test) => Check)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * @param {Test | null | undefined} [test]\r\n     * @returns {Check}\r\n     */\r\n    function (test) {\r\n      if (test === null || test === undefined) {\r\n        return element\r\n      }\r\n\r\n      if (typeof test === 'string') {\r\n        return tagNameFactory(test)\r\n      }\r\n\r\n      // Assume array.\r\n      if (typeof test === 'object') {\r\n        return anyFactory(test)\r\n      }\r\n\r\n      if (typeof test === 'function') {\r\n        return castFactory(test)\r\n      }\r\n\r\n      throw new Error('Expected function, string, or array as `test`')\r\n    }\r\n  )\r\n\r\n/**\r\n * Handle multiple tests.\r\n *\r\n * @param {Array<TestFunction | string>} tests\r\n * @returns {Check}\r\n */\r\nfunction anyFactory(tests) {\r\n  /** @type {Array<Check>} */\r\n  const checks = []\r\n  let index = -1\r\n\r\n  while (++index < tests.length) {\r\n    checks[index] = convertElement(tests[index])\r\n  }\r\n\r\n  return castFactory(any)\r\n\r\n  /**\r\n   * @this {unknown}\r\n   * @type {TestFunction}\r\n   */\r\n  function any(...parameters) {\r\n    let index = -1\r\n\r\n    while (++index < checks.length) {\r\n      if (checks[index].apply(this, parameters)) return true\r\n    }\r\n\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Turn a string into a test for an element with a certain type.\r\n *\r\n * @param {string} check\r\n * @returns {Check}\r\n */\r\nfunction tagNameFactory(check) {\r\n  return castFactory(tagName)\r\n\r\n  /**\r\n   * @param {Element} element\r\n   * @returns {boolean}\r\n   */\r\n  function tagName(element) {\r\n    return element.tagName === check\r\n  }\r\n}\r\n\r\n/**\r\n * Turn a custom test into a test for an element that passes that test.\r\n *\r\n * @param {TestFunction} testFunction\r\n * @returns {Check}\r\n */\r\nfunction castFactory(testFunction) {\r\n  return check\r\n\r\n  /**\r\n   * @this {unknown}\r\n   * @type {Check}\r\n   */\r\n  function check(value, index, parent) {\r\n    return Boolean(\r\n      looksLikeAnElement(value) &&\r\n        testFunction.call(\r\n          this,\r\n          value,\r\n          typeof index === 'number' ? index : undefined,\r\n          parent || undefined\r\n        )\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * Make sure something is an element.\r\n *\r\n * @param {unknown} element\r\n * @returns {element is Element}\r\n */\r\nfunction element(element) {\r\n  return Boolean(\r\n    element &&\r\n      typeof element === 'object' &&\r\n      'type' in element &&\r\n      element.type === 'element' &&\r\n      'tagName' in element &&\r\n      typeof element.tagName === 'string'\r\n  )\r\n}\r\n\r\n/**\r\n * @param {unknown} value\r\n * @returns {value is Element}\r\n */\r\nfunction looksLikeAnElement(value) {\r\n  return (\r\n    value !== null &&\r\n    typeof value === 'object' &&\r\n    'type' in value &&\r\n    'tagName' in value\r\n  )\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,SAAS;AACpB;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACI;AACA,SAAAA,CAAUC,OAAO,EAAEC,IAAI,EAAEC,KAAK,EAAEC,MAAM,EAAEC,OAAO,EAAE;EAC/C,MAAMC,KAAK,GAAGC,cAAc,CAACL,IAAI,CAAC;EAElC,IACEC,KAAK,KAAK,IAAI,IACdA,KAAK,KAAKK,SAAS,KAClB,OAAOL,KAAK,KAAK,QAAQ,IACxBA,KAAK,GAAG,CAAC,IACTA,KAAK,KAAKM,MAAM,CAACC,iBAAiB,CAAC,EACrC;IACA,MAAM,IAAIC,KAAK,CAAC,kCAAkC,CAAC;EACrD;EAEA,IACEP,MAAM,KAAK,IAAI,IACfA,MAAM,KAAKI,SAAS,KACnB,CAACJ,MAAM,CAACQ,IAAI,IAAI,CAACR,MAAM,CAACS,QAAQ,CAAC,EAClC;IACA,MAAM,IAAIF,KAAK,CAAC,yBAAyB,CAAC;EAC5C;EAEA,IACE,CAACR,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKK,SAAS,OACrCJ,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAKI,SAAS,CAAC,EACzC;IACA,MAAM,IAAIG,KAAK,CAAC,oCAAoC,CAAC;EACvD;EAEA,OAAOG,kBAAkB,CAACb,OAAO,CAAC,GAC9BK,KAAK,CAACS,IAAI,CAACV,OAAO,EAAEJ,OAAO,EAAEE,KAAK,EAAEC,MAAM,CAAC,GAC3C,KAAK;AACX,CACD;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMG,cAAc;AACzB;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACI,SAAAA,CAAUL,IAAI,EAAE;EACd,IAAIA,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAKM,SAAS,EAAE;IACvC,OAAOP,OAAO;EAChB;EAEA,IAAI,OAAOC,IAAI,KAAK,QAAQ,EAAE;IAC5B,OAAOc,cAAc,CAACd,IAAI,CAAC;EAC7B;;EAEA;EACA,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IAC5B,OAAOe,UAAU,CAACf,IAAI,CAAC;EACzB;EAEA,IAAI,OAAOA,IAAI,KAAK,UAAU,EAAE;IAC9B,OAAOgB,WAAW,CAAChB,IAAI,CAAC;EAC1B;EAEA,MAAM,IAAIS,KAAK,CAAC,+CAA+C,CAAC;AAClE,CACD;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,SAASM,UAAUA,CAACE,KAAK,EAAE;EACzB;EACA,MAAMC,MAAM,GAAG,EAAE;EACjB,IAAIjB,KAAK,GAAG,CAAC,CAAC;EAEd,OAAO,EAAEA,KAAK,GAAGgB,KAAK,CAACE,MAAM,EAAE;IAC7BD,MAAM,CAACjB,KAAK,CAAC,GAAGI,cAAc,CAACY,KAAK,CAAChB,KAAK,CAAC,CAAC;EAC9C;EAEA,OAAOe,WAAW,CAACI,GAAG,CAAC;;EAEvB;AACF;AACA;AACA;EACE,SAASA,GAAGA,CAAC,GAAGC,UAAU,EAAE;IAC1B,IAAIpB,KAAK,GAAG,CAAC,CAAC;IAEd,OAAO,EAAEA,KAAK,GAAGiB,MAAM,CAACC,MAAM,EAAE;MAC9B,IAAID,MAAM,CAACjB,KAAK,CAAC,CAACqB,KAAK,CAAC,IAAI,EAAED,UAAU,CAAC,EAAE,OAAO,IAAI;IACxD;IAEA,OAAO,KAAK;EACd;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASP,cAAcA,CAACV,KAAK,EAAE;EAC7B,OAAOY,WAAW,CAACO,OAAO,CAAC;;EAE3B;AACF;AACA;AACA;EACE,SAASA,OAAOA,CAACxB,OAAO,EAAE;IACxB,OAAOA,OAAO,CAACwB,OAAO,KAAKnB,KAAK;EAClC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASY,WAAWA,CAACQ,YAAY,EAAE;EACjC,OAAOpB,KAAK;;EAEZ;AACF;AACA;AACA;EACE,SAASA,KAAKA,CAACqB,KAAK,EAAExB,KAAK,EAAEC,MAAM,EAAE;IACnC,OAAOwB,OAAO,CACZd,kBAAkB,CAACa,KAAK,CAAC,IACvBD,YAAY,CAACX,IAAI,CACf,IAAI,EACJY,KAAK,EACL,OAAOxB,KAAK,KAAK,QAAQ,GAAGA,KAAK,GAAGK,SAAS,EAC7CJ,MAAM,IAAII,SACZ,CACJ,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASP,OAAOA,CAACA,OAAO,EAAE;EACxB,OAAO2B,OAAO,CACZ3B,OAAO,IACL,OAAOA,OAAO,KAAK,QAAQ,IAC3B,MAAM,IAAIA,OAAO,IACjBA,OAAO,CAACW,IAAI,KAAK,SAAS,IAC1B,SAAS,IAAIX,OAAO,IACpB,OAAOA,OAAO,CAACwB,OAAO,KAAK,QAC/B,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA,SAASX,kBAAkBA,CAACa,KAAK,EAAE;EACjC,OACEA,KAAK,KAAK,IAAI,IACd,OAAOA,KAAK,KAAK,QAAQ,IACzB,MAAM,IAAIA,KAAK,IACf,SAAS,IAAIA,KAAK;AAEtB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}