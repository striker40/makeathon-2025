{"ast":null,"code":"/**\r\n * @import {Identifier, Literal, MemberExpression} from 'estree'\r\n * @import {Jsx, JsxDev, Options, Props} from 'hast-util-to-jsx-runtime'\r\n * @import {Element, Nodes, Parents, Root, Text} from 'hast'\r\n * @import {MdxFlowExpressionHast, MdxTextExpressionHast} from 'mdast-util-mdx-expression'\r\n * @import {MdxJsxFlowElementHast, MdxJsxTextElementHast} from 'mdast-util-mdx-jsx'\r\n * @import {MdxjsEsmHast} from 'mdast-util-mdxjs-esm'\r\n * @import {Position} from 'unist'\r\n * @import {Child, Create, Field, JsxElement, State, Style} from './types.js'\r\n */\n\nimport { stringify as commas } from 'comma-separated-tokens';\nimport { ok as assert } from 'devlop';\nimport { name as isIdentifierName } from 'estree-util-is-identifier-name';\nimport { whitespace } from 'hast-util-whitespace';\nimport { find, hastToReact, html, svg } from 'property-information';\nimport { stringify as spaces } from 'space-separated-tokens';\nimport styleToJs from 'style-to-js';\nimport { pointStart } from 'unist-util-position';\nimport { VFileMessage } from 'vfile-message';\n\n// To do: next major: `Object.hasOwn`.\nconst own = {}.hasOwnProperty;\n\n/** @type {Map<string, number>} */\nconst emptyMap = new Map();\nconst cap = /[A-Z]/g;\n\n// `react-dom` triggers a warning for *any* white space in tables.\n// To follow GFM, `mdast-util-to-hast` injects line endings between elements.\n// Other tools might do so too, but they donâ€™t do here, so we remove all of\n// that.\n\n// See: <https://github.com/facebook/react/pull/7081>.\n// See: <https://github.com/facebook/react/pull/7515>.\n// See: <https://github.com/remarkjs/remark-react/issues/64>.\n// See: <https://github.com/rehypejs/rehype-react/pull/29>.\n// See: <https://github.com/rehypejs/rehype-react/pull/32>.\n// See: <https://github.com/rehypejs/rehype-react/pull/45>.\nconst tableElements = new Set(['table', 'tbody', 'thead', 'tfoot', 'tr']);\nconst tableCellElement = new Set(['td', 'th']);\nconst docs = 'https://github.com/syntax-tree/hast-util-to-jsx-runtime';\n\n/**\r\n * Transform a hast tree to preact, react, solid, svelte, vue, etc.,\r\n * with an automatic JSX runtime.\r\n *\r\n * @param {Nodes} tree\r\n *   Tree to transform.\r\n * @param {Options} options\r\n *   Configuration (required).\r\n * @returns {JsxElement}\r\n *   JSX element.\r\n */\n\nexport function toJsxRuntime(tree, options) {\n  if (!options || options.Fragment === undefined) {\n    throw new TypeError('Expected `Fragment` in options');\n  }\n  const filePath = options.filePath || undefined;\n  /** @type {Create} */\n  let create;\n  if (options.development) {\n    if (typeof options.jsxDEV !== 'function') {\n      throw new TypeError('Expected `jsxDEV` in options when `development: true`');\n    }\n    create = developmentCreate(filePath, options.jsxDEV);\n  } else {\n    if (typeof options.jsx !== 'function') {\n      throw new TypeError('Expected `jsx` in production options');\n    }\n    if (typeof options.jsxs !== 'function') {\n      throw new TypeError('Expected `jsxs` in production options');\n    }\n    create = productionCreate(filePath, options.jsx, options.jsxs);\n  }\n\n  /** @type {State} */\n  const state = {\n    Fragment: options.Fragment,\n    ancestors: [],\n    components: options.components || {},\n    create,\n    elementAttributeNameCase: options.elementAttributeNameCase || 'react',\n    evaluater: options.createEvaluater ? options.createEvaluater() : undefined,\n    filePath,\n    ignoreInvalidStyle: options.ignoreInvalidStyle || false,\n    passKeys: options.passKeys !== false,\n    passNode: options.passNode || false,\n    schema: options.space === 'svg' ? svg : html,\n    stylePropertyNameCase: options.stylePropertyNameCase || 'dom',\n    tableCellAlignToStyle: options.tableCellAlignToStyle !== false\n  };\n  const result = one(state, tree, undefined);\n\n  // JSX element.\n  if (result && typeof result !== 'string') {\n    return result;\n  }\n\n  // Text node or something that turned into nothing.\n  return state.create(tree, state.Fragment, {\n    children: result || undefined\n  }, undefined);\n}\n\n/**\r\n * Transform a node.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Nodes} node\r\n *   Current node.\r\n * @param {string | undefined} key\r\n *   Key.\r\n * @returns {Child | undefined}\r\n *   Child, optional.\r\n */\nfunction one(state, node, key) {\n  if (node.type === 'element') {\n    return element(state, node, key);\n  }\n  if (node.type === 'mdxFlowExpression' || node.type === 'mdxTextExpression') {\n    return mdxExpression(state, node);\n  }\n  if (node.type === 'mdxJsxFlowElement' || node.type === 'mdxJsxTextElement') {\n    return mdxJsxElement(state, node, key);\n  }\n  if (node.type === 'mdxjsEsm') {\n    return mdxEsm(state, node);\n  }\n  if (node.type === 'root') {\n    return root(state, node, key);\n  }\n  if (node.type === 'text') {\n    return text(state, node);\n  }\n}\n\n/**\r\n * Handle element.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Element} node\r\n *   Current node.\r\n * @param {string | undefined} key\r\n *   Key.\r\n * @returns {Child | undefined}\r\n *   Child, optional.\r\n */\nfunction element(state, node, key) {\n  const parentSchema = state.schema;\n  let schema = parentSchema;\n  if (node.tagName.toLowerCase() === 'svg' && parentSchema.space === 'html') {\n    schema = svg;\n    state.schema = schema;\n  }\n  state.ancestors.push(node);\n  const type = findComponentFromName(state, node.tagName, false);\n  const props = createElementProps(state, node);\n  let children = createChildren(state, node);\n  if (tableElements.has(node.tagName)) {\n    children = children.filter(function (child) {\n      return typeof child === 'string' ? !whitespace(child) : true;\n    });\n  }\n  addNode(state, props, type, node);\n  addChildren(props, children);\n\n  // Restore.\n  state.ancestors.pop();\n  state.schema = parentSchema;\n  return state.create(node, type, props, key);\n}\n\n/**\r\n * Handle MDX expression.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {MdxFlowExpressionHast | MdxTextExpressionHast} node\r\n *   Current node.\r\n * @returns {Child | undefined}\r\n *   Child, optional.\r\n */\nfunction mdxExpression(state, node) {\n  if (node.data && node.data.estree && state.evaluater) {\n    const program = node.data.estree;\n    const expression = program.body[0];\n    assert(expression.type === 'ExpressionStatement');\n\n    // Assume result is a child.\n    return /** @type {Child | undefined} */state.evaluater.evaluateExpression(expression.expression);\n  }\n  crashEstree(state, node.position);\n}\n\n/**\r\n * Handle MDX ESM.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {MdxjsEsmHast} node\r\n *   Current node.\r\n * @returns {Child | undefined}\r\n *   Child, optional.\r\n */\nfunction mdxEsm(state, node) {\n  if (node.data && node.data.estree && state.evaluater) {\n    // Assume result is a child.\n    return /** @type {Child | undefined} */state.evaluater.evaluateProgram(node.data.estree);\n  }\n  crashEstree(state, node.position);\n}\n\n/**\r\n * Handle MDX JSX.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {MdxJsxFlowElementHast | MdxJsxTextElementHast} node\r\n *   Current node.\r\n * @param {string | undefined} key\r\n *   Key.\r\n * @returns {Child | undefined}\r\n *   Child, optional.\r\n */\nfunction mdxJsxElement(state, node, key) {\n  const parentSchema = state.schema;\n  let schema = parentSchema;\n  if (node.name === 'svg' && parentSchema.space === 'html') {\n    schema = svg;\n    state.schema = schema;\n  }\n  state.ancestors.push(node);\n  const type = node.name === null ? state.Fragment : findComponentFromName(state, node.name, true);\n  const props = createJsxElementProps(state, node);\n  const children = createChildren(state, node);\n  addNode(state, props, type, node);\n  addChildren(props, children);\n\n  // Restore.\n  state.ancestors.pop();\n  state.schema = parentSchema;\n  return state.create(node, type, props, key);\n}\n\n/**\r\n * Handle root.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Root} node\r\n *   Current node.\r\n * @param {string | undefined} key\r\n *   Key.\r\n * @returns {Child | undefined}\r\n *   Child, optional.\r\n */\nfunction root(state, node, key) {\n  /** @type {Props} */\n  const props = {};\n  addChildren(props, createChildren(state, node));\n  return state.create(node, state.Fragment, props, key);\n}\n\n/**\r\n * Handle text.\r\n *\r\n * @param {State} _\r\n *   Info passed around.\r\n * @param {Text} node\r\n *   Current node.\r\n * @returns {Child | undefined}\r\n *   Child, optional.\r\n */\nfunction text(_, node) {\n  return node.value;\n}\n\n/**\r\n * Add `node` to props.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Props} props\r\n *   Props.\r\n * @param {unknown} type\r\n *   Type.\r\n * @param {Element | MdxJsxFlowElementHast | MdxJsxTextElementHast} node\r\n *   Node.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\nfunction addNode(state, props, type, node) {\n  // If this is swapped out for a component:\n  if (typeof type !== 'string' && type !== state.Fragment && state.passNode) {\n    props.node = node;\n  }\n}\n\n/**\r\n * Add children to props.\r\n *\r\n * @param {Props} props\r\n *   Props.\r\n * @param {Array<Child>} children\r\n *   Children.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\nfunction addChildren(props, children) {\n  if (children.length > 0) {\n    const value = children.length > 1 ? children : children[0];\n    if (value) {\n      props.children = value;\n    }\n  }\n}\n\n/**\r\n * @param {string | undefined} _\r\n *   Path to file.\r\n * @param {Jsx} jsx\r\n *   Dynamic.\r\n * @param {Jsx} jsxs\r\n *   Static.\r\n * @returns {Create}\r\n *   Create a production element.\r\n */\nfunction productionCreate(_, jsx, jsxs) {\n  return create;\n  /** @type {Create} */\n  function create(_, type, props, key) {\n    // Only an array when there are 2 or more children.\n    const isStaticChildren = Array.isArray(props.children);\n    const fn = isStaticChildren ? jsxs : jsx;\n    return key ? fn(type, props, key) : fn(type, props);\n  }\n}\n\n/**\r\n * @param {string | undefined} filePath\r\n *   Path to file.\r\n * @param {JsxDev} jsxDEV\r\n *   Development.\r\n * @returns {Create}\r\n *   Create a development element.\r\n */\nfunction developmentCreate(filePath, jsxDEV) {\n  return create;\n  /** @type {Create} */\n  function create(node, type, props, key) {\n    // Only an array when there are 2 or more children.\n    const isStaticChildren = Array.isArray(props.children);\n    const point = pointStart(node);\n    return jsxDEV(type, props, key, isStaticChildren, {\n      columnNumber: point ? point.column - 1 : undefined,\n      fileName: filePath,\n      lineNumber: point ? point.line : undefined\n    }, undefined);\n  }\n}\n\n/**\r\n * Create props from an element.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Element} node\r\n *   Current element.\r\n * @returns {Props}\r\n *   Props.\r\n */\nfunction createElementProps(state, node) {\n  /** @type {Props} */\n  const props = {};\n  /** @type {string | undefined} */\n  let alignValue;\n  /** @type {string} */\n  let prop;\n  for (prop in node.properties) {\n    if (prop !== 'children' && own.call(node.properties, prop)) {\n      const result = createProperty(state, prop, node.properties[prop]);\n      if (result) {\n        const [key, value] = result;\n        if (state.tableCellAlignToStyle && key === 'align' && typeof value === 'string' && tableCellElement.has(node.tagName)) {\n          alignValue = value;\n        } else {\n          props[key] = value;\n        }\n      }\n    }\n  }\n  if (alignValue) {\n    // Assume style is an object.\n    const style = /** @type {Style} */props.style || (props.style = {});\n    style[state.stylePropertyNameCase === 'css' ? 'text-align' : 'textAlign'] = alignValue;\n  }\n  return props;\n}\n\n/**\r\n * Create props from a JSX element.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {MdxJsxFlowElementHast | MdxJsxTextElementHast} node\r\n *   Current JSX element.\r\n * @returns {Props}\r\n *   Props.\r\n */\nfunction createJsxElementProps(state, node) {\n  /** @type {Props} */\n  const props = {};\n  for (const attribute of node.attributes) {\n    if (attribute.type === 'mdxJsxExpressionAttribute') {\n      if (attribute.data && attribute.data.estree && state.evaluater) {\n        const program = attribute.data.estree;\n        const expression = program.body[0];\n        assert(expression.type === 'ExpressionStatement');\n        const objectExpression = expression.expression;\n        assert(objectExpression.type === 'ObjectExpression');\n        const property = objectExpression.properties[0];\n        assert(property.type === 'SpreadElement');\n        Object.assign(props, state.evaluater.evaluateExpression(property.argument));\n      } else {\n        crashEstree(state, node.position);\n      }\n    } else {\n      // For JSX, the author is responsible of passing in the correct values.\n      const name = attribute.name;\n      /** @type {unknown} */\n      let value;\n      if (attribute.value && typeof attribute.value === 'object') {\n        if (attribute.value.data && attribute.value.data.estree && state.evaluater) {\n          const program = attribute.value.data.estree;\n          const expression = program.body[0];\n          assert(expression.type === 'ExpressionStatement');\n          value = state.evaluater.evaluateExpression(expression.expression);\n        } else {\n          crashEstree(state, node.position);\n        }\n      } else {\n        value = attribute.value === null ? true : attribute.value;\n      }\n\n      // Assume a prop.\n      props[name] = /** @type {Props[keyof Props]} */value;\n    }\n  }\n  return props;\n}\n\n/**\r\n * Create children.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Parents} node\r\n *   Current element.\r\n * @returns {Array<Child>}\r\n *   Children.\r\n */\nfunction createChildren(state, node) {\n  /** @type {Array<Child>} */\n  const children = [];\n  let index = -1;\n  /** @type {Map<string, number>} */\n  // Note: test this when Solid doesnâ€™t want to merge my upcoming PR.\n  /* c8 ignore next */\n  const countsByName = state.passKeys ? new Map() : emptyMap;\n  while (++index < node.children.length) {\n    const child = node.children[index];\n    /** @type {string | undefined} */\n    let key;\n    if (state.passKeys) {\n      const name = child.type === 'element' ? child.tagName : child.type === 'mdxJsxFlowElement' || child.type === 'mdxJsxTextElement' ? child.name : undefined;\n      if (name) {\n        const count = countsByName.get(name) || 0;\n        key = name + '-' + count;\n        countsByName.set(name, count + 1);\n      }\n    }\n    const result = one(state, child, key);\n    if (result !== undefined) children.push(result);\n  }\n  return children;\n}\n\n/**\r\n * Handle a property.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {string} prop\r\n *   Key.\r\n * @param {Array<number | string> | boolean | number | string | null | undefined} value\r\n *   hast property value.\r\n * @returns {Field | undefined}\r\n *   Field for runtime, optional.\r\n */\nfunction createProperty(state, prop, value) {\n  const info = find(state.schema, prop);\n\n  // Ignore nullish and `NaN` values.\n  if (value === null || value === undefined || typeof value === 'number' && Number.isNaN(value)) {\n    return;\n  }\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? commas(value) : spaces(value);\n  }\n\n  // React only accepts `style` as object.\n  if (info.property === 'style') {\n    let styleObject = typeof value === 'object' ? value : parseStyle(state, String(value));\n    if (state.stylePropertyNameCase === 'css') {\n      styleObject = transformStylesToCssCasing(styleObject);\n    }\n    return ['style', styleObject];\n  }\n  return [state.elementAttributeNameCase === 'react' && info.space ? hastToReact[info.property] || info.property : info.attribute, value];\n}\n\n/**\r\n * Parse a CSS declaration to an object.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {string} value\r\n *   CSS declarations.\r\n * @returns {Style}\r\n *   Properties.\r\n * @throws\r\n *   Throws `VFileMessage` when CSS cannot be parsed.\r\n */\nfunction parseStyle(state, value) {\n  try {\n    return styleToJs(value, {\n      reactCompat: true\n    });\n  } catch (error) {\n    if (state.ignoreInvalidStyle) {\n      return {};\n    }\n    const cause = /** @type {Error} */error;\n    const message = new VFileMessage('Cannot parse `style` attribute', {\n      ancestors: state.ancestors,\n      cause,\n      ruleId: 'style',\n      source: 'hast-util-to-jsx-runtime'\n    });\n    message.file = state.filePath || undefined;\n    message.url = docs + '#cannot-parse-style-attribute';\n    throw message;\n  }\n}\n\n/**\r\n * Create a JSX name from a string.\r\n *\r\n * @param {State} state\r\n *   To do.\r\n * @param {string} name\r\n *   Name.\r\n * @param {boolean} allowExpression\r\n *   Allow member expressions and identifiers.\r\n * @returns {unknown}\r\n *   To do.\r\n */\nfunction findComponentFromName(state, name, allowExpression) {\n  /** @type {Identifier | Literal | MemberExpression} */\n  let result;\n  if (!allowExpression) {\n    result = {\n      type: 'Literal',\n      value: name\n    };\n  } else if (name.includes('.')) {\n    const identifiers = name.split('.');\n    let index = -1;\n    /** @type {Identifier | Literal | MemberExpression | undefined} */\n    let node;\n    while (++index < identifiers.length) {\n      /** @type {Identifier | Literal} */\n      const prop = isIdentifierName(identifiers[index]) ? {\n        type: 'Identifier',\n        name: identifiers[index]\n      } : {\n        type: 'Literal',\n        value: identifiers[index]\n      };\n      node = node ? {\n        type: 'MemberExpression',\n        object: node,\n        property: prop,\n        computed: Boolean(index && prop.type === 'Literal'),\n        optional: false\n      } : prop;\n    }\n    assert(node, 'always a result');\n    result = node;\n  } else {\n    result = isIdentifierName(name) && !/^[a-z]/.test(name) ? {\n      type: 'Identifier',\n      name\n    } : {\n      type: 'Literal',\n      value: name\n    };\n  }\n\n  // Only literals can be passed in `components` currently.\n  // No identifiers / member expressions.\n  if (result.type === 'Literal') {\n    const name = /** @type {string | number} */result.value;\n    return own.call(state.components, name) ? state.components[name] : name;\n  }\n\n  // Assume component.\n  if (state.evaluater) {\n    return state.evaluater.evaluateExpression(result);\n  }\n  crashEstree(state);\n}\n\n/**\r\n * @param {State} state\r\n * @param {Position | undefined} [place]\r\n * @returns {never}\r\n */\nfunction crashEstree(state, place) {\n  const message = new VFileMessage('Cannot handle MDX estrees without `createEvaluater`', {\n    ancestors: state.ancestors,\n    place,\n    ruleId: 'mdx-estree',\n    source: 'hast-util-to-jsx-runtime'\n  });\n  message.file = state.filePath || undefined;\n  message.url = docs + '#cannot-handle-mdx-estrees-without-createevaluater';\n  throw message;\n}\n\n/**\r\n * Transform a DOM casing style object to a CSS casing style object.\r\n *\r\n * @param {Style} domCasing\r\n * @returns {Style}\r\n */\nfunction transformStylesToCssCasing(domCasing) {\n  /** @type {Style} */\n  const cssCasing = {};\n  /** @type {string} */\n  let from;\n  for (from in domCasing) {\n    if (own.call(domCasing, from)) {\n      cssCasing[transformStyleToCssCasing(from)] = domCasing[from];\n    }\n  }\n  return cssCasing;\n}\n\n/**\r\n * Transform a DOM casing style field to a CSS casing style field.\r\n *\r\n * @param {string} from\r\n * @returns {string}\r\n */\nfunction transformStyleToCssCasing(from) {\n  let to = from.replace(cap, toDash);\n  // Handle `ms-xxx` -> `-ms-xxx`.\n  if (to.slice(0, 3) === 'ms-') to = '-' + to;\n  return to;\n}\n\n/**\r\n * Make `$0` dash cased.\r\n *\r\n * @param {string} $0\r\n *   Capitalized ASCII leter.\r\n * @returns {string}\r\n *   Dash and lower letter.\r\n */\nfunction toDash($0) {\n  return '-' + $0.toLowerCase();\n}","map":{"version":3,"names":["stringify","commas","ok","assert","name","isIdentifierName","whitespace","find","hastToReact","html","svg","spaces","styleToJs","pointStart","VFileMessage","own","hasOwnProperty","emptyMap","Map","cap","tableElements","Set","tableCellElement","docs","toJsxRuntime","tree","options","Fragment","undefined","TypeError","filePath","create","development","jsxDEV","developmentCreate","jsx","jsxs","productionCreate","state","ancestors","components","elementAttributeNameCase","evaluater","createEvaluater","ignoreInvalidStyle","passKeys","passNode","schema","space","stylePropertyNameCase","tableCellAlignToStyle","result","one","children","node","key","type","element","mdxExpression","mdxJsxElement","mdxEsm","root","text","parentSchema","tagName","toLowerCase","push","findComponentFromName","props","createElementProps","createChildren","has","filter","child","addNode","addChildren","pop","data","estree","program","expression","body","evaluateExpression","crashEstree","position","evaluateProgram","createJsxElementProps","_","value","length","isStaticChildren","Array","isArray","fn","point","columnNumber","column","fileName","lineNumber","line","alignValue","prop","properties","call","createProperty","style","attribute","attributes","objectExpression","property","Object","assign","argument","index","countsByName","count","get","set","info","Number","isNaN","commaSeparated","styleObject","parseStyle","String","transformStylesToCssCasing","reactCompat","error","cause","message","ruleId","source","file","url","allowExpression","includes","identifiers","split","object","computed","Boolean","optional","test","place","domCasing","cssCasing","from","transformStyleToCssCasing","to","replace","toDash","slice","$0"],"sources":["C:/Users/smart/Downloads/Final Project P20119/makeathon-2025/makeathon/node_modules/hast-util-to-jsx-runtime/lib/index.js"],"sourcesContent":["/**\r\n * @import {Identifier, Literal, MemberExpression} from 'estree'\r\n * @import {Jsx, JsxDev, Options, Props} from 'hast-util-to-jsx-runtime'\r\n * @import {Element, Nodes, Parents, Root, Text} from 'hast'\r\n * @import {MdxFlowExpressionHast, MdxTextExpressionHast} from 'mdast-util-mdx-expression'\r\n * @import {MdxJsxFlowElementHast, MdxJsxTextElementHast} from 'mdast-util-mdx-jsx'\r\n * @import {MdxjsEsmHast} from 'mdast-util-mdxjs-esm'\r\n * @import {Position} from 'unist'\r\n * @import {Child, Create, Field, JsxElement, State, Style} from './types.js'\r\n */\r\n\r\nimport {stringify as commas} from 'comma-separated-tokens'\r\nimport {ok as assert} from 'devlop'\r\nimport {name as isIdentifierName} from 'estree-util-is-identifier-name'\r\nimport {whitespace} from 'hast-util-whitespace'\r\nimport {find, hastToReact, html, svg} from 'property-information'\r\nimport {stringify as spaces} from 'space-separated-tokens'\r\nimport styleToJs from 'style-to-js'\r\nimport {pointStart} from 'unist-util-position'\r\nimport {VFileMessage} from 'vfile-message'\r\n\r\n// To do: next major: `Object.hasOwn`.\r\nconst own = {}.hasOwnProperty\r\n\r\n/** @type {Map<string, number>} */\r\nconst emptyMap = new Map()\r\n\r\nconst cap = /[A-Z]/g\r\n\r\n// `react-dom` triggers a warning for *any* white space in tables.\r\n// To follow GFM, `mdast-util-to-hast` injects line endings between elements.\r\n// Other tools might do so too, but they donâ€™t do here, so we remove all of\r\n// that.\r\n\r\n// See: <https://github.com/facebook/react/pull/7081>.\r\n// See: <https://github.com/facebook/react/pull/7515>.\r\n// See: <https://github.com/remarkjs/remark-react/issues/64>.\r\n// See: <https://github.com/rehypejs/rehype-react/pull/29>.\r\n// See: <https://github.com/rehypejs/rehype-react/pull/32>.\r\n// See: <https://github.com/rehypejs/rehype-react/pull/45>.\r\nconst tableElements = new Set(['table', 'tbody', 'thead', 'tfoot', 'tr'])\r\n\r\nconst tableCellElement = new Set(['td', 'th'])\r\n\r\nconst docs = 'https://github.com/syntax-tree/hast-util-to-jsx-runtime'\r\n\r\n/**\r\n * Transform a hast tree to preact, react, solid, svelte, vue, etc.,\r\n * with an automatic JSX runtime.\r\n *\r\n * @param {Nodes} tree\r\n *   Tree to transform.\r\n * @param {Options} options\r\n *   Configuration (required).\r\n * @returns {JsxElement}\r\n *   JSX element.\r\n */\r\n\r\nexport function toJsxRuntime(tree, options) {\r\n  if (!options || options.Fragment === undefined) {\r\n    throw new TypeError('Expected `Fragment` in options')\r\n  }\r\n\r\n  const filePath = options.filePath || undefined\r\n  /** @type {Create} */\r\n  let create\r\n\r\n  if (options.development) {\r\n    if (typeof options.jsxDEV !== 'function') {\r\n      throw new TypeError(\r\n        'Expected `jsxDEV` in options when `development: true`'\r\n      )\r\n    }\r\n\r\n    create = developmentCreate(filePath, options.jsxDEV)\r\n  } else {\r\n    if (typeof options.jsx !== 'function') {\r\n      throw new TypeError('Expected `jsx` in production options')\r\n    }\r\n\r\n    if (typeof options.jsxs !== 'function') {\r\n      throw new TypeError('Expected `jsxs` in production options')\r\n    }\r\n\r\n    create = productionCreate(filePath, options.jsx, options.jsxs)\r\n  }\r\n\r\n  /** @type {State} */\r\n  const state = {\r\n    Fragment: options.Fragment,\r\n    ancestors: [],\r\n    components: options.components || {},\r\n    create,\r\n    elementAttributeNameCase: options.elementAttributeNameCase || 'react',\r\n    evaluater: options.createEvaluater ? options.createEvaluater() : undefined,\r\n    filePath,\r\n    ignoreInvalidStyle: options.ignoreInvalidStyle || false,\r\n    passKeys: options.passKeys !== false,\r\n    passNode: options.passNode || false,\r\n    schema: options.space === 'svg' ? svg : html,\r\n    stylePropertyNameCase: options.stylePropertyNameCase || 'dom',\r\n    tableCellAlignToStyle: options.tableCellAlignToStyle !== false\r\n  }\r\n\r\n  const result = one(state, tree, undefined)\r\n\r\n  // JSX element.\r\n  if (result && typeof result !== 'string') {\r\n    return result\r\n  }\r\n\r\n  // Text node or something that turned into nothing.\r\n  return state.create(\r\n    tree,\r\n    state.Fragment,\r\n    {children: result || undefined},\r\n    undefined\r\n  )\r\n}\r\n\r\n/**\r\n * Transform a node.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Nodes} node\r\n *   Current node.\r\n * @param {string | undefined} key\r\n *   Key.\r\n * @returns {Child | undefined}\r\n *   Child, optional.\r\n */\r\nfunction one(state, node, key) {\r\n  if (node.type === 'element') {\r\n    return element(state, node, key)\r\n  }\r\n\r\n  if (node.type === 'mdxFlowExpression' || node.type === 'mdxTextExpression') {\r\n    return mdxExpression(state, node)\r\n  }\r\n\r\n  if (node.type === 'mdxJsxFlowElement' || node.type === 'mdxJsxTextElement') {\r\n    return mdxJsxElement(state, node, key)\r\n  }\r\n\r\n  if (node.type === 'mdxjsEsm') {\r\n    return mdxEsm(state, node)\r\n  }\r\n\r\n  if (node.type === 'root') {\r\n    return root(state, node, key)\r\n  }\r\n\r\n  if (node.type === 'text') {\r\n    return text(state, node)\r\n  }\r\n}\r\n\r\n/**\r\n * Handle element.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Element} node\r\n *   Current node.\r\n * @param {string | undefined} key\r\n *   Key.\r\n * @returns {Child | undefined}\r\n *   Child, optional.\r\n */\r\nfunction element(state, node, key) {\r\n  const parentSchema = state.schema\r\n  let schema = parentSchema\r\n\r\n  if (node.tagName.toLowerCase() === 'svg' && parentSchema.space === 'html') {\r\n    schema = svg\r\n    state.schema = schema\r\n  }\r\n\r\n  state.ancestors.push(node)\r\n\r\n  const type = findComponentFromName(state, node.tagName, false)\r\n  const props = createElementProps(state, node)\r\n  let children = createChildren(state, node)\r\n\r\n  if (tableElements.has(node.tagName)) {\r\n    children = children.filter(function (child) {\r\n      return typeof child === 'string' ? !whitespace(child) : true\r\n    })\r\n  }\r\n\r\n  addNode(state, props, type, node)\r\n  addChildren(props, children)\r\n\r\n  // Restore.\r\n  state.ancestors.pop()\r\n  state.schema = parentSchema\r\n\r\n  return state.create(node, type, props, key)\r\n}\r\n\r\n/**\r\n * Handle MDX expression.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {MdxFlowExpressionHast | MdxTextExpressionHast} node\r\n *   Current node.\r\n * @returns {Child | undefined}\r\n *   Child, optional.\r\n */\r\nfunction mdxExpression(state, node) {\r\n  if (node.data && node.data.estree && state.evaluater) {\r\n    const program = node.data.estree\r\n    const expression = program.body[0]\r\n    assert(expression.type === 'ExpressionStatement')\r\n\r\n    // Assume result is a child.\r\n    return /** @type {Child | undefined} */ (\r\n      state.evaluater.evaluateExpression(expression.expression)\r\n    )\r\n  }\r\n\r\n  crashEstree(state, node.position)\r\n}\r\n\r\n/**\r\n * Handle MDX ESM.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {MdxjsEsmHast} node\r\n *   Current node.\r\n * @returns {Child | undefined}\r\n *   Child, optional.\r\n */\r\nfunction mdxEsm(state, node) {\r\n  if (node.data && node.data.estree && state.evaluater) {\r\n    // Assume result is a child.\r\n    return /** @type {Child | undefined} */ (\r\n      state.evaluater.evaluateProgram(node.data.estree)\r\n    )\r\n  }\r\n\r\n  crashEstree(state, node.position)\r\n}\r\n\r\n/**\r\n * Handle MDX JSX.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {MdxJsxFlowElementHast | MdxJsxTextElementHast} node\r\n *   Current node.\r\n * @param {string | undefined} key\r\n *   Key.\r\n * @returns {Child | undefined}\r\n *   Child, optional.\r\n */\r\nfunction mdxJsxElement(state, node, key) {\r\n  const parentSchema = state.schema\r\n  let schema = parentSchema\r\n\r\n  if (node.name === 'svg' && parentSchema.space === 'html') {\r\n    schema = svg\r\n    state.schema = schema\r\n  }\r\n\r\n  state.ancestors.push(node)\r\n\r\n  const type =\r\n    node.name === null\r\n      ? state.Fragment\r\n      : findComponentFromName(state, node.name, true)\r\n  const props = createJsxElementProps(state, node)\r\n  const children = createChildren(state, node)\r\n\r\n  addNode(state, props, type, node)\r\n  addChildren(props, children)\r\n\r\n  // Restore.\r\n  state.ancestors.pop()\r\n  state.schema = parentSchema\r\n\r\n  return state.create(node, type, props, key)\r\n}\r\n\r\n/**\r\n * Handle root.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Root} node\r\n *   Current node.\r\n * @param {string | undefined} key\r\n *   Key.\r\n * @returns {Child | undefined}\r\n *   Child, optional.\r\n */\r\nfunction root(state, node, key) {\r\n  /** @type {Props} */\r\n  const props = {}\r\n\r\n  addChildren(props, createChildren(state, node))\r\n\r\n  return state.create(node, state.Fragment, props, key)\r\n}\r\n\r\n/**\r\n * Handle text.\r\n *\r\n * @param {State} _\r\n *   Info passed around.\r\n * @param {Text} node\r\n *   Current node.\r\n * @returns {Child | undefined}\r\n *   Child, optional.\r\n */\r\nfunction text(_, node) {\r\n  return node.value\r\n}\r\n\r\n/**\r\n * Add `node` to props.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Props} props\r\n *   Props.\r\n * @param {unknown} type\r\n *   Type.\r\n * @param {Element | MdxJsxFlowElementHast | MdxJsxTextElementHast} node\r\n *   Node.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nfunction addNode(state, props, type, node) {\r\n  // If this is swapped out for a component:\r\n  if (typeof type !== 'string' && type !== state.Fragment && state.passNode) {\r\n    props.node = node\r\n  }\r\n}\r\n\r\n/**\r\n * Add children to props.\r\n *\r\n * @param {Props} props\r\n *   Props.\r\n * @param {Array<Child>} children\r\n *   Children.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nfunction addChildren(props, children) {\r\n  if (children.length > 0) {\r\n    const value = children.length > 1 ? children : children[0]\r\n\r\n    if (value) {\r\n      props.children = value\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {string | undefined} _\r\n *   Path to file.\r\n * @param {Jsx} jsx\r\n *   Dynamic.\r\n * @param {Jsx} jsxs\r\n *   Static.\r\n * @returns {Create}\r\n *   Create a production element.\r\n */\r\nfunction productionCreate(_, jsx, jsxs) {\r\n  return create\r\n  /** @type {Create} */\r\n  function create(_, type, props, key) {\r\n    // Only an array when there are 2 or more children.\r\n    const isStaticChildren = Array.isArray(props.children)\r\n    const fn = isStaticChildren ? jsxs : jsx\r\n    return key ? fn(type, props, key) : fn(type, props)\r\n  }\r\n}\r\n\r\n/**\r\n * @param {string | undefined} filePath\r\n *   Path to file.\r\n * @param {JsxDev} jsxDEV\r\n *   Development.\r\n * @returns {Create}\r\n *   Create a development element.\r\n */\r\nfunction developmentCreate(filePath, jsxDEV) {\r\n  return create\r\n  /** @type {Create} */\r\n  function create(node, type, props, key) {\r\n    // Only an array when there are 2 or more children.\r\n    const isStaticChildren = Array.isArray(props.children)\r\n    const point = pointStart(node)\r\n    return jsxDEV(\r\n      type,\r\n      props,\r\n      key,\r\n      isStaticChildren,\r\n      {\r\n        columnNumber: point ? point.column - 1 : undefined,\r\n        fileName: filePath,\r\n        lineNumber: point ? point.line : undefined\r\n      },\r\n      undefined\r\n    )\r\n  }\r\n}\r\n\r\n/**\r\n * Create props from an element.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Element} node\r\n *   Current element.\r\n * @returns {Props}\r\n *   Props.\r\n */\r\nfunction createElementProps(state, node) {\r\n  /** @type {Props} */\r\n  const props = {}\r\n  /** @type {string | undefined} */\r\n  let alignValue\r\n  /** @type {string} */\r\n  let prop\r\n\r\n  for (prop in node.properties) {\r\n    if (prop !== 'children' && own.call(node.properties, prop)) {\r\n      const result = createProperty(state, prop, node.properties[prop])\r\n\r\n      if (result) {\r\n        const [key, value] = result\r\n\r\n        if (\r\n          state.tableCellAlignToStyle &&\r\n          key === 'align' &&\r\n          typeof value === 'string' &&\r\n          tableCellElement.has(node.tagName)\r\n        ) {\r\n          alignValue = value\r\n        } else {\r\n          props[key] = value\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (alignValue) {\r\n    // Assume style is an object.\r\n    const style = /** @type {Style} */ (props.style || (props.style = {}))\r\n    style[state.stylePropertyNameCase === 'css' ? 'text-align' : 'textAlign'] =\r\n      alignValue\r\n  }\r\n\r\n  return props\r\n}\r\n\r\n/**\r\n * Create props from a JSX element.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {MdxJsxFlowElementHast | MdxJsxTextElementHast} node\r\n *   Current JSX element.\r\n * @returns {Props}\r\n *   Props.\r\n */\r\nfunction createJsxElementProps(state, node) {\r\n  /** @type {Props} */\r\n  const props = {}\r\n\r\n  for (const attribute of node.attributes) {\r\n    if (attribute.type === 'mdxJsxExpressionAttribute') {\r\n      if (attribute.data && attribute.data.estree && state.evaluater) {\r\n        const program = attribute.data.estree\r\n        const expression = program.body[0]\r\n        assert(expression.type === 'ExpressionStatement')\r\n        const objectExpression = expression.expression\r\n        assert(objectExpression.type === 'ObjectExpression')\r\n        const property = objectExpression.properties[0]\r\n        assert(property.type === 'SpreadElement')\r\n\r\n        Object.assign(\r\n          props,\r\n          state.evaluater.evaluateExpression(property.argument)\r\n        )\r\n      } else {\r\n        crashEstree(state, node.position)\r\n      }\r\n    } else {\r\n      // For JSX, the author is responsible of passing in the correct values.\r\n      const name = attribute.name\r\n      /** @type {unknown} */\r\n      let value\r\n\r\n      if (attribute.value && typeof attribute.value === 'object') {\r\n        if (\r\n          attribute.value.data &&\r\n          attribute.value.data.estree &&\r\n          state.evaluater\r\n        ) {\r\n          const program = attribute.value.data.estree\r\n          const expression = program.body[0]\r\n          assert(expression.type === 'ExpressionStatement')\r\n          value = state.evaluater.evaluateExpression(expression.expression)\r\n        } else {\r\n          crashEstree(state, node.position)\r\n        }\r\n      } else {\r\n        value = attribute.value === null ? true : attribute.value\r\n      }\r\n\r\n      // Assume a prop.\r\n      props[name] = /** @type {Props[keyof Props]} */ (value)\r\n    }\r\n  }\r\n\r\n  return props\r\n}\r\n\r\n/**\r\n * Create children.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {Parents} node\r\n *   Current element.\r\n * @returns {Array<Child>}\r\n *   Children.\r\n */\r\nfunction createChildren(state, node) {\r\n  /** @type {Array<Child>} */\r\n  const children = []\r\n  let index = -1\r\n  /** @type {Map<string, number>} */\r\n  // Note: test this when Solid doesnâ€™t want to merge my upcoming PR.\r\n  /* c8 ignore next */\r\n  const countsByName = state.passKeys ? new Map() : emptyMap\r\n\r\n  while (++index < node.children.length) {\r\n    const child = node.children[index]\r\n    /** @type {string | undefined} */\r\n    let key\r\n\r\n    if (state.passKeys) {\r\n      const name =\r\n        child.type === 'element'\r\n          ? child.tagName\r\n          : child.type === 'mdxJsxFlowElement' ||\r\n              child.type === 'mdxJsxTextElement'\r\n            ? child.name\r\n            : undefined\r\n\r\n      if (name) {\r\n        const count = countsByName.get(name) || 0\r\n        key = name + '-' + count\r\n        countsByName.set(name, count + 1)\r\n      }\r\n    }\r\n\r\n    const result = one(state, child, key)\r\n    if (result !== undefined) children.push(result)\r\n  }\r\n\r\n  return children\r\n}\r\n\r\n/**\r\n * Handle a property.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {string} prop\r\n *   Key.\r\n * @param {Array<number | string> | boolean | number | string | null | undefined} value\r\n *   hast property value.\r\n * @returns {Field | undefined}\r\n *   Field for runtime, optional.\r\n */\r\nfunction createProperty(state, prop, value) {\r\n  const info = find(state.schema, prop)\r\n\r\n  // Ignore nullish and `NaN` values.\r\n  if (\r\n    value === null ||\r\n    value === undefined ||\r\n    (typeof value === 'number' && Number.isNaN(value))\r\n  ) {\r\n    return\r\n  }\r\n\r\n  if (Array.isArray(value)) {\r\n    // Accept `array`.\r\n    // Most props are space-separated.\r\n    value = info.commaSeparated ? commas(value) : spaces(value)\r\n  }\r\n\r\n  // React only accepts `style` as object.\r\n  if (info.property === 'style') {\r\n    let styleObject =\r\n      typeof value === 'object' ? value : parseStyle(state, String(value))\r\n\r\n    if (state.stylePropertyNameCase === 'css') {\r\n      styleObject = transformStylesToCssCasing(styleObject)\r\n    }\r\n\r\n    return ['style', styleObject]\r\n  }\r\n\r\n  return [\r\n    state.elementAttributeNameCase === 'react' && info.space\r\n      ? hastToReact[info.property] || info.property\r\n      : info.attribute,\r\n    value\r\n  ]\r\n}\r\n\r\n/**\r\n * Parse a CSS declaration to an object.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {string} value\r\n *   CSS declarations.\r\n * @returns {Style}\r\n *   Properties.\r\n * @throws\r\n *   Throws `VFileMessage` when CSS cannot be parsed.\r\n */\r\nfunction parseStyle(state, value) {\r\n  try {\r\n    return styleToJs(value, {reactCompat: true})\r\n  } catch (error) {\r\n    if (state.ignoreInvalidStyle) {\r\n      return {}\r\n    }\r\n\r\n    const cause = /** @type {Error} */ (error)\r\n    const message = new VFileMessage('Cannot parse `style` attribute', {\r\n      ancestors: state.ancestors,\r\n      cause,\r\n      ruleId: 'style',\r\n      source: 'hast-util-to-jsx-runtime'\r\n    })\r\n    message.file = state.filePath || undefined\r\n    message.url = docs + '#cannot-parse-style-attribute'\r\n\r\n    throw message\r\n  }\r\n}\r\n\r\n/**\r\n * Create a JSX name from a string.\r\n *\r\n * @param {State} state\r\n *   To do.\r\n * @param {string} name\r\n *   Name.\r\n * @param {boolean} allowExpression\r\n *   Allow member expressions and identifiers.\r\n * @returns {unknown}\r\n *   To do.\r\n */\r\nfunction findComponentFromName(state, name, allowExpression) {\r\n  /** @type {Identifier | Literal | MemberExpression} */\r\n  let result\r\n\r\n  if (!allowExpression) {\r\n    result = {type: 'Literal', value: name}\r\n  } else if (name.includes('.')) {\r\n    const identifiers = name.split('.')\r\n    let index = -1\r\n    /** @type {Identifier | Literal | MemberExpression | undefined} */\r\n    let node\r\n\r\n    while (++index < identifiers.length) {\r\n      /** @type {Identifier | Literal} */\r\n      const prop = isIdentifierName(identifiers[index])\r\n        ? {type: 'Identifier', name: identifiers[index]}\r\n        : {type: 'Literal', value: identifiers[index]}\r\n      node = node\r\n        ? {\r\n            type: 'MemberExpression',\r\n            object: node,\r\n            property: prop,\r\n            computed: Boolean(index && prop.type === 'Literal'),\r\n            optional: false\r\n          }\r\n        : prop\r\n    }\r\n\r\n    assert(node, 'always a result')\r\n    result = node\r\n  } else {\r\n    result =\r\n      isIdentifierName(name) && !/^[a-z]/.test(name)\r\n        ? {type: 'Identifier', name}\r\n        : {type: 'Literal', value: name}\r\n  }\r\n\r\n  // Only literals can be passed in `components` currently.\r\n  // No identifiers / member expressions.\r\n  if (result.type === 'Literal') {\r\n    const name = /** @type {string | number} */ (result.value)\r\n    return own.call(state.components, name) ? state.components[name] : name\r\n  }\r\n\r\n  // Assume component.\r\n  if (state.evaluater) {\r\n    return state.evaluater.evaluateExpression(result)\r\n  }\r\n\r\n  crashEstree(state)\r\n}\r\n\r\n/**\r\n * @param {State} state\r\n * @param {Position | undefined} [place]\r\n * @returns {never}\r\n */\r\nfunction crashEstree(state, place) {\r\n  const message = new VFileMessage(\r\n    'Cannot handle MDX estrees without `createEvaluater`',\r\n    {\r\n      ancestors: state.ancestors,\r\n      place,\r\n      ruleId: 'mdx-estree',\r\n      source: 'hast-util-to-jsx-runtime'\r\n    }\r\n  )\r\n  message.file = state.filePath || undefined\r\n  message.url = docs + '#cannot-handle-mdx-estrees-without-createevaluater'\r\n\r\n  throw message\r\n}\r\n\r\n/**\r\n * Transform a DOM casing style object to a CSS casing style object.\r\n *\r\n * @param {Style} domCasing\r\n * @returns {Style}\r\n */\r\nfunction transformStylesToCssCasing(domCasing) {\r\n  /** @type {Style} */\r\n  const cssCasing = {}\r\n  /** @type {string} */\r\n  let from\r\n\r\n  for (from in domCasing) {\r\n    if (own.call(domCasing, from)) {\r\n      cssCasing[transformStyleToCssCasing(from)] = domCasing[from]\r\n    }\r\n  }\r\n\r\n  return cssCasing\r\n}\r\n\r\n/**\r\n * Transform a DOM casing style field to a CSS casing style field.\r\n *\r\n * @param {string} from\r\n * @returns {string}\r\n */\r\nfunction transformStyleToCssCasing(from) {\r\n  let to = from.replace(cap, toDash)\r\n  // Handle `ms-xxx` -> `-ms-xxx`.\r\n  if (to.slice(0, 3) === 'ms-') to = '-' + to\r\n  return to\r\n}\r\n\r\n/**\r\n * Make `$0` dash cased.\r\n *\r\n * @param {string} $0\r\n *   Capitalized ASCII leter.\r\n * @returns {string}\r\n *   Dash and lower letter.\r\n */\r\nfunction toDash($0) {\r\n  return '-' + $0.toLowerCase()\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}