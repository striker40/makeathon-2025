{"ast":null,"code":"/**\r\n * @import {Handle, Info, State} from 'mdast-util-to-markdown'\r\n * @import {PhrasingParents} from '../types.js'\r\n */\n\nimport { encodeCharacterReference } from './encode-character-reference.js';\n\n/**\r\n * Serialize the children of a parent that contains phrasing children.\r\n *\r\n * These children will be joined flush together.\r\n *\r\n * @param {PhrasingParents} parent\r\n *   Parent of flow nodes.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @param {Info} info\r\n *   Info on where we are in the document we are generating.\r\n * @returns {string}\r\n *   Serialized children, joined together.\r\n */\nexport function containerPhrasing(parent, state, info) {\n  const indexStack = state.indexStack;\n  const children = parent.children || [];\n  /** @type {Array<string>} */\n  const results = [];\n  let index = -1;\n  let before = info.before;\n  /** @type {string | undefined} */\n  let encodeAfter;\n  indexStack.push(-1);\n  let tracker = state.createTracker(info);\n  while (++index < children.length) {\n    const child = children[index];\n    /** @type {string} */\n    let after;\n    indexStack[indexStack.length - 1] = index;\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = state.handle.handlers[children[index + 1].type];\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek;\n      after = handle ? handle(children[index + 1], parent, state, {\n        before: '',\n        after: '',\n        ...tracker.current()\n      }).charAt(0) : '';\n    } else {\n      after = info.after;\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (results.length > 0 && (before === '\\r' || before === '\\n') && child.type === 'html') {\n      results[results.length - 1] = results[results.length - 1].replace(/(\\r?\\n|\\r)$/, ' ');\n      before = ' ';\n\n      // To do: does this work to reset tracker?\n      tracker = state.createTracker(info);\n      tracker.move(results.join(''));\n    }\n    let value = state.handle(child, parent, state, {\n      ...tracker.current(),\n      after,\n      before\n    });\n\n    // If we had to encode the first character after the previous node and it’s\n    // still the same character,\n    // encode it.\n    if (encodeAfter && encodeAfter === value.slice(0, 1)) {\n      value = encodeCharacterReference(encodeAfter.charCodeAt(0)) + value.slice(1);\n    }\n    const encodingInfo = state.attentionEncodeSurroundingInfo;\n    state.attentionEncodeSurroundingInfo = undefined;\n    encodeAfter = undefined;\n\n    // If we have to encode the first character before the current node and\n    // it’s still the same character,\n    // encode it.\n    if (encodingInfo) {\n      if (results.length > 0 && encodingInfo.before && before === results[results.length - 1].slice(-1)) {\n        results[results.length - 1] = results[results.length - 1].slice(0, -1) + encodeCharacterReference(before.charCodeAt(0));\n      }\n      if (encodingInfo.after) encodeAfter = after;\n    }\n    tracker.move(value);\n    results.push(value);\n    before = value.slice(-1);\n  }\n  indexStack.pop();\n  return results.join('');\n}","map":{"version":3,"names":["encodeCharacterReference","containerPhrasing","parent","state","info","indexStack","children","results","index","before","encodeAfter","push","tracker","createTracker","length","child","after","handle","handlers","type","peek","current","charAt","replace","move","join","value","slice","charCodeAt","encodingInfo","attentionEncodeSurroundingInfo","undefined","pop"],"sources":["C:/Users/smart/Downloads/Final Project P20119/makeathon-2025/makeathon/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js"],"sourcesContent":["/**\r\n * @import {Handle, Info, State} from 'mdast-util-to-markdown'\r\n * @import {PhrasingParents} from '../types.js'\r\n */\r\n\r\nimport {encodeCharacterReference} from './encode-character-reference.js'\r\n\r\n/**\r\n * Serialize the children of a parent that contains phrasing children.\r\n *\r\n * These children will be joined flush together.\r\n *\r\n * @param {PhrasingParents} parent\r\n *   Parent of flow nodes.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @param {Info} info\r\n *   Info on where we are in the document we are generating.\r\n * @returns {string}\r\n *   Serialized children, joined together.\r\n */\r\nexport function containerPhrasing(parent, state, info) {\r\n  const indexStack = state.indexStack\r\n  const children = parent.children || []\r\n  /** @type {Array<string>} */\r\n  const results = []\r\n  let index = -1\r\n  let before = info.before\r\n  /** @type {string | undefined} */\r\n  let encodeAfter\r\n\r\n  indexStack.push(-1)\r\n  let tracker = state.createTracker(info)\r\n\r\n  while (++index < children.length) {\r\n    const child = children[index]\r\n    /** @type {string} */\r\n    let after\r\n\r\n    indexStack[indexStack.length - 1] = index\r\n\r\n    if (index + 1 < children.length) {\r\n      /** @type {Handle} */\r\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\r\n      let handle = state.handle.handlers[children[index + 1].type]\r\n      /** @type {Handle} */\r\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\r\n      if (handle && handle.peek) handle = handle.peek\r\n      after = handle\r\n        ? handle(children[index + 1], parent, state, {\r\n            before: '',\r\n            after: '',\r\n            ...tracker.current()\r\n          }).charAt(0)\r\n        : ''\r\n    } else {\r\n      after = info.after\r\n    }\r\n\r\n    // In some cases, html (text) can be found in phrasing right after an eol.\r\n    // When we’d serialize that, in most cases that would be seen as html\r\n    // (flow).\r\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\r\n    // reasonable approach: replace that eol with a space.\r\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\r\n    if (\r\n      results.length > 0 &&\r\n      (before === '\\r' || before === '\\n') &&\r\n      child.type === 'html'\r\n    ) {\r\n      results[results.length - 1] = results[results.length - 1].replace(\r\n        /(\\r?\\n|\\r)$/,\r\n        ' '\r\n      )\r\n      before = ' '\r\n\r\n      // To do: does this work to reset tracker?\r\n      tracker = state.createTracker(info)\r\n      tracker.move(results.join(''))\r\n    }\r\n\r\n    let value = state.handle(child, parent, state, {\r\n      ...tracker.current(),\r\n      after,\r\n      before\r\n    })\r\n\r\n    // If we had to encode the first character after the previous node and it’s\r\n    // still the same character,\r\n    // encode it.\r\n    if (encodeAfter && encodeAfter === value.slice(0, 1)) {\r\n      value =\r\n        encodeCharacterReference(encodeAfter.charCodeAt(0)) + value.slice(1)\r\n    }\r\n\r\n    const encodingInfo = state.attentionEncodeSurroundingInfo\r\n    state.attentionEncodeSurroundingInfo = undefined\r\n    encodeAfter = undefined\r\n\r\n    // If we have to encode the first character before the current node and\r\n    // it’s still the same character,\r\n    // encode it.\r\n    if (encodingInfo) {\r\n      if (\r\n        results.length > 0 &&\r\n        encodingInfo.before &&\r\n        before === results[results.length - 1].slice(-1)\r\n      ) {\r\n        results[results.length - 1] =\r\n          results[results.length - 1].slice(0, -1) +\r\n          encodeCharacterReference(before.charCodeAt(0))\r\n      }\r\n\r\n      if (encodingInfo.after) encodeAfter = after\r\n    }\r\n\r\n    tracker.move(value)\r\n    results.push(value)\r\n    before = value.slice(-1)\r\n  }\r\n\r\n  indexStack.pop()\r\n\r\n  return results.join('')\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}