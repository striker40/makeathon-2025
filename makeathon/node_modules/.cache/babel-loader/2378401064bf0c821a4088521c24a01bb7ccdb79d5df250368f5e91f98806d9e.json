{"ast":null,"code":"/**\r\n * @import {Options} from 'hast-util-raw'\r\n * @import {Comment, Doctype, Element, Nodes, RootContent, Root, Text} from 'hast'\r\n * @import {Raw} from 'mdast-util-to-hast'\r\n * @import {DefaultTreeAdapterMap, ParserOptions} from 'parse5'\r\n * @import {Point} from 'unist'\r\n */\n\n/**\r\n * @typedef State\r\n *   Info passed around about the current state.\r\n * @property {(node: Nodes) => undefined} handle\r\n *   Add a hast node to the parser.\r\n * @property {Options} options\r\n *   User configuration.\r\n * @property {Parser<DefaultTreeAdapterMap>} parser\r\n *   Current parser.\r\n * @property {boolean} stitches\r\n *   Whether there are stitches.\r\n */\n\n/**\r\n * @typedef Stitch\r\n *   Custom comment-like value we pass through parse5, which contains a\r\n *   replacement node that we’ll swap back in afterwards.\r\n * @property {'comment'} type\r\n *   Node type.\r\n * @property {{stitch: Nodes}} value\r\n *   Replacement value.\r\n */\n\nimport structuredClone from '@ungap/structured-clone';\nimport { fromParse5 } from 'hast-util-from-parse5';\nimport { toParse5 } from 'hast-util-to-parse5';\nimport { htmlVoidElements } from 'html-void-elements';\nimport { Parser, Token, TokenizerMode, html } from 'parse5';\nimport { pointEnd, pointStart } from 'unist-util-position';\nimport { visit } from 'unist-util-visit';\nimport { webNamespaces } from 'web-namespaces';\nimport { zwitch } from 'zwitch';\nconst gfmTagfilterExpression = /<(\\/?)(iframe|noembed|noframes|plaintext|script|style|textarea|title|xmp)(?=[\\t\\n\\f\\r />])/gi;\n\n// Node types associated with MDX.\n// <https://github.com/mdx-js/mdx/blob/8a56312/packages/mdx/lib/node-types.js>\nconst knownMdxNames = new Set(['mdxFlowExpression', 'mdxJsxFlowElement', 'mdxJsxTextElement', 'mdxTextExpression', 'mdxjsEsm']);\n\n/** @type {ParserOptions<DefaultTreeAdapterMap>} */\nconst parseOptions = {\n  sourceCodeLocationInfo: true,\n  scriptingEnabled: false\n};\n\n/**\r\n * Pass a hast tree through an HTML parser, which will fix nesting, and turn\r\n * raw nodes into actual nodes.\r\n *\r\n * @param {Nodes} tree\r\n *   Original hast tree to transform.\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration (optional).\r\n * @returns {Nodes}\r\n *   Parsed again tree.\r\n */\nexport function raw(tree, options) {\n  const document = documentMode(tree);\n  /** @type {(node: Nodes, state: State) => undefined} */\n  const one = zwitch('type', {\n    handlers: {\n      root,\n      element,\n      text,\n      comment,\n      doctype,\n      raw: handleRaw\n    },\n    unknown\n  });\n\n  /** @type {State} */\n  const state = {\n    parser: document ? new Parser(parseOptions) : Parser.getFragmentParser(undefined, parseOptions),\n    handle(node) {\n      one(node, state);\n    },\n    stitches: false,\n    options: options || {}\n  };\n  one(tree, state);\n  resetTokenizer(state, pointStart());\n  const p5 = document ? state.parser.document : state.parser.getFragment();\n  const result = fromParse5(p5, {\n    // To do: support `space`?\n    file: state.options.file\n  });\n  if (state.stitches) {\n    visit(result, 'comment', function (node, index, parent) {\n      const stitch = /** @type {Stitch} */ /** @type {unknown} */node;\n      if (stitch.value.stitch && parent && index !== undefined) {\n        /** @type {Array<RootContent>} */\n        const siblings = parent.children;\n        // @ts-expect-error: assume the stitch is allowed.\n        siblings[index] = stitch.value.stitch;\n        return index;\n      }\n    });\n  }\n\n  // Unpack if possible and when not given a `root`.\n  if (result.type === 'root' && result.children.length === 1 && result.children[0].type === tree.type) {\n    return result.children[0];\n  }\n  return result;\n}\n\n/**\r\n * Transform all nodes\r\n *\r\n * @param {Array<RootContent>} nodes\r\n *   hast content.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\nfunction all(nodes, state) {\n  let index = -1;\n\n  /* istanbul ignore else - invalid nodes, see rehypejs/rehype-raw#7. */\n  if (nodes) {\n    while (++index < nodes.length) {\n      state.handle(nodes[index]);\n    }\n  }\n}\n\n/**\r\n * Transform a root.\r\n *\r\n * @param {Root} node\r\n *   hast root node.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\nfunction root(node, state) {\n  all(node.children, state);\n}\n\n/**\r\n * Transform an element.\r\n *\r\n * @param {Element} node\r\n *   hast element node.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\nfunction element(node, state) {\n  startTag(node, state);\n  all(node.children, state);\n  endTag(node, state);\n}\n\n/**\r\n * Transform a text.\r\n *\r\n * @param {Text} node\r\n *   hast text node.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\nfunction text(node, state) {\n  // Allow `DATA` through `PLAINTEXT`,\n  // but when hanging in a tag for example,\n  // switch back to `DATA`.\n  // Note: `State` is not exposed by `parse5`, so these numbers are fragile.\n  // See: <https://github.com/inikulin/parse5/blob/46cba43/packages/parse5/lib/tokenizer/index.ts#L58>\n  if (state.parser.tokenizer.state > 4) {\n    state.parser.tokenizer.state = 0;\n  }\n\n  /** @type {Token.CharacterToken} */\n  const token = {\n    type: Token.TokenType.CHARACTER,\n    chars: node.value,\n    location: createParse5Location(node)\n  };\n  resetTokenizer(state, pointStart(node));\n  // @ts-expect-error: private.\n  state.parser.currentToken = token;\n  // @ts-expect-error: private.\n  state.parser._processToken(state.parser.currentToken);\n}\n\n/**\r\n * Transform a doctype.\r\n *\r\n * @param {Doctype} node\r\n *   hast doctype node.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\nfunction doctype(node, state) {\n  /** @type {Token.DoctypeToken} */\n  const token = {\n    type: Token.TokenType.DOCTYPE,\n    name: 'html',\n    forceQuirks: false,\n    publicId: '',\n    systemId: '',\n    location: createParse5Location(node)\n  };\n  resetTokenizer(state, pointStart(node));\n  // @ts-expect-error: private.\n  state.parser.currentToken = token;\n  // @ts-expect-error: private.\n  state.parser._processToken(state.parser.currentToken);\n}\n\n/**\r\n * Transform a stitch.\r\n *\r\n * @param {Nodes} node\r\n *   unknown node.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\nfunction stitch(node, state) {\n  // Mark that there are stitches, so we need to walk the tree and revert them.\n  state.stitches = true;\n\n  /** @type {Nodes} */\n  const clone = cloneWithoutChildren(node);\n\n  // Recurse, because to somewhat handle `[<x>]</x>` (where `[]` denotes the\n  // passed through node).\n  if ('children' in node && 'children' in clone) {\n    // Root in root out.\n    const fakeRoot = /** @type {Root} */\n    raw({\n      type: 'root',\n      children: node.children\n    }, state.options);\n    clone.children = fakeRoot.children;\n  }\n\n  // Hack: `value` is supposed to be a string, but as none of the tools\n  // (`parse5` or `hast-util-from-parse5`) looks at it, we can pass nodes\n  // through.\n  comment({\n    type: 'comment',\n    value: {\n      stitch: clone\n    }\n  }, state);\n}\n\n/**\r\n * Transform a comment (or stitch).\r\n *\r\n * @param {Comment | Stitch} node\r\n *   hast comment node.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\nfunction comment(node, state) {\n  /** @type {string} */\n  // @ts-expect-error: we pass stitches through.\n  const data = node.value;\n\n  /** @type {Token.CommentToken} */\n  const token = {\n    type: Token.TokenType.COMMENT,\n    data,\n    location: createParse5Location(node)\n  };\n  resetTokenizer(state, pointStart(node));\n  // @ts-expect-error: private.\n  state.parser.currentToken = token;\n  // @ts-expect-error: private.\n  state.parser._processToken(state.parser.currentToken);\n}\n\n/**\r\n * Transform a raw node.\r\n *\r\n * @param {Raw} node\r\n *   hast raw node.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\nfunction handleRaw(node, state) {\n  // Reset preprocessor:\n  // See: <https://github.com/inikulin/parse5/blob/6f7ca60/packages/parse5/lib/tokenizer/preprocessor.ts#L18-L31>.\n  state.parser.tokenizer.preprocessor.html = '';\n  state.parser.tokenizer.preprocessor.pos = -1;\n  // @ts-expect-error: private.\n  // type-coverage:ignore-next-line\n  state.parser.tokenizer.preprocessor.lastGapPos = -2;\n  // @ts-expect-error: private.\n  // type-coverage:ignore-next-line\n  state.parser.tokenizer.preprocessor.gapStack = [];\n  // @ts-expect-error: private.\n  // type-coverage:ignore-next-line\n  state.parser.tokenizer.preprocessor.skipNextNewLine = false;\n  state.parser.tokenizer.preprocessor.lastChunkWritten = false;\n  state.parser.tokenizer.preprocessor.endOfChunkHit = false;\n  // @ts-expect-error: private.\n  // type-coverage:ignore-next-line\n  state.parser.tokenizer.preprocessor.isEol = false;\n\n  // Now pass `node.value`.\n  setPoint(state, pointStart(node));\n  state.parser.tokenizer.write(state.options.tagfilter ? node.value.replace(gfmTagfilterExpression, '&lt;$1$2') : node.value, false);\n  // @ts-expect-error: private.\n  state.parser.tokenizer._runParsingLoop();\n\n  // Character references hang, so if we ended there, we need to flush\n  // those too.\n  // We reset the preprocessor as if the document ends here.\n  // Then one single call to the relevant state does the trick, parse5\n  // consumes the whole token.\n\n  // Note: `State` is not exposed by `parse5`, so these numbers are fragile.\n  // See: <https://github.com/inikulin/parse5/blob/46cba43/packages/parse5/lib/tokenizer/index.ts#L58>\n  // Note: a change to `parse5`, which breaks this, was merged but not released.\n  // Investigate when it is.\n  // To do: remove next major.\n  /* c8 ignore next 12 -- removed in <https://github.com/inikulin/parse5/pull/897> */\n  if (state.parser.tokenizer.state === 72 /* NAMED_CHARACTER_REFERENCE */ ||\n  // @ts-expect-error: removed.\n  state.parser.tokenizer.state === 78 /* NUMERIC_CHARACTER_REFERENCE_END */) {\n    state.parser.tokenizer.preprocessor.lastChunkWritten = true;\n    /** @type {number} */\n    // @ts-expect-error: private.\n    const cp = state.parser.tokenizer._consume();\n    // @ts-expect-error: private.\n    state.parser.tokenizer._callState(cp);\n  }\n}\n\n/**\r\n * Crash on an unknown node.\r\n *\r\n * @param {unknown} node_\r\n *   unknown node.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Never.\r\n */\nfunction unknown(node_, state) {\n  const node = /** @type {Nodes} */node_;\n  if (state.options.passThrough && state.options.passThrough.includes(node.type)) {\n    stitch(node, state);\n  } else {\n    let extra = '';\n    if (knownMdxNames.has(node.type)) {\n      extra = \". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax\";\n    }\n    throw new Error('Cannot compile `' + node.type + '` node' + extra);\n  }\n}\n\n/**\r\n * Reset the tokenizer of a parser.\r\n *\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @param {Point | undefined} point\r\n *   Point.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\nfunction resetTokenizer(state, point) {\n  setPoint(state, point);\n\n  // Process final characters if they’re still there after hibernating.\n  /** @type {Token.CharacterToken} */\n  // @ts-expect-error: private.\n  const token = state.parser.tokenizer.currentCharacterToken;\n  if (token && token.location) {\n    token.location.endLine = state.parser.tokenizer.preprocessor.line;\n    token.location.endCol = state.parser.tokenizer.preprocessor.col + 1;\n    token.location.endOffset = state.parser.tokenizer.preprocessor.offset + 1;\n    // @ts-expect-error: private.\n    state.parser.currentToken = token;\n    // @ts-expect-error: private.\n    state.parser._processToken(state.parser.currentToken);\n  }\n\n  // Reset tokenizer:\n  // See: <https://github.com/inikulin/parse5/blob/6f7ca60/packages/parse5/lib/tokenizer/index.ts#L187-L223>.\n  // Especially putting it back in the `data` state is useful: some elements,\n  // like textareas and iframes, change the state.\n  // See GH-7.\n  // But also if broken HTML is in `raw`, and then a correct element is given.\n  // See GH-11.\n  // @ts-expect-error: private.\n  state.parser.tokenizer.paused = false;\n  // @ts-expect-error: private.\n  state.parser.tokenizer.inLoop = false;\n\n  // Note: don’t reset `state`, `inForeignNode`, or `lastStartTagName`, we\n  // manually update those when needed.\n  state.parser.tokenizer.active = false;\n  // @ts-expect-error: private.\n  state.parser.tokenizer.returnState = TokenizerMode.DATA;\n  // @ts-expect-error: private.\n  state.parser.tokenizer.charRefCode = -1;\n  // @ts-expect-error: private.\n  state.parser.tokenizer.consumedAfterSnapshot = -1;\n  // @ts-expect-error: private.\n  state.parser.tokenizer.currentLocation = null;\n  // @ts-expect-error: private.\n  state.parser.tokenizer.currentCharacterToken = null;\n  // @ts-expect-error: private.\n  state.parser.tokenizer.currentToken = null;\n  // @ts-expect-error: private.\n  state.parser.tokenizer.currentAttr = {\n    name: '',\n    value: ''\n  };\n}\n\n/**\r\n * Set current location.\r\n *\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @param {Point | undefined} point\r\n *   Point.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\nfunction setPoint(state, point) {\n  if (point && point.offset !== undefined) {\n    /** @type {Token.Location} */\n    const location = {\n      startLine: point.line,\n      startCol: point.column,\n      startOffset: point.offset,\n      endLine: -1,\n      endCol: -1,\n      endOffset: -1\n    };\n\n    // @ts-expect-error: private.\n    // type-coverage:ignore-next-line\n    state.parser.tokenizer.preprocessor.lineStartPos = -point.column + 1; // Looks weird, but ensures we get correct positional info.\n    state.parser.tokenizer.preprocessor.droppedBufferSize = point.offset;\n    state.parser.tokenizer.preprocessor.line = point.line;\n    // @ts-expect-error: private.\n    state.parser.tokenizer.currentLocation = location;\n  }\n}\n\n/**\r\n * Emit a start tag.\r\n *\r\n * @param {Element} node\r\n *   Element.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\nfunction startTag(node, state) {\n  const tagName = node.tagName.toLowerCase();\n\n  // Ignore tags if we’re in plain text.\n  if (state.parser.tokenizer.state === TokenizerMode.PLAINTEXT) return;\n  resetTokenizer(state, pointStart(node));\n  const current = state.parser.openElements.current;\n  let ns = 'namespaceURI' in current ? current.namespaceURI : webNamespaces.html;\n  if (ns === webNamespaces.html && tagName === 'svg') {\n    ns = webNamespaces.svg;\n  }\n  const result = toParse5(\n  // Shallow clone to not delve into `children`: we only need the attributes.\n  {\n    ...node,\n    children: []\n  }, {\n    space: ns === webNamespaces.svg ? 'svg' : 'html'\n  });\n\n  /** @type {Token.TagToken} */\n  const tag = {\n    type: Token.TokenType.START_TAG,\n    tagName,\n    tagID: html.getTagID(tagName),\n    // We always send start and end tags.\n    selfClosing: false,\n    ackSelfClosing: false,\n    // Always element.\n    /* c8 ignore next */\n    attrs: 'attrs' in result ? result.attrs : [],\n    location: createParse5Location(node)\n  };\n\n  // The HTML parsing algorithm works by doing half of the state management in\n  // the tokenizer and half in the parser.\n  // We can’t use the tokenizer here, as we don’t have strings.\n  // So we act *as if* the tokenizer emits tokens:\n\n  // @ts-expect-error: private.\n  state.parser.currentToken = tag;\n  // @ts-expect-error: private.\n  state.parser._processToken(state.parser.currentToken);\n\n  // …but then we still need a bunch of work that the tokenizer would normally\n  // do, such as:\n\n  // Set a tag name, similar to how the tokenizer would do it.\n  state.parser.tokenizer.lastStartTagName = tagName;\n\n  // `inForeignNode` is correctly set by the parser.\n}\n\n/**\r\n * Emit an end tag.\r\n *\r\n * @param {Element} node\r\n *   Element.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\nfunction endTag(node, state) {\n  const tagName = node.tagName.toLowerCase();\n  // Do not emit closing tags for HTML void elements.\n  if (!state.parser.tokenizer.inForeignNode && htmlVoidElements.includes(tagName)) {\n    return;\n  }\n\n  // Ignore tags if we’re in plain text.\n  if (state.parser.tokenizer.state === TokenizerMode.PLAINTEXT) return;\n  resetTokenizer(state, pointEnd(node));\n\n  /** @type {Token.TagToken} */\n  const tag = {\n    type: Token.TokenType.END_TAG,\n    tagName,\n    tagID: html.getTagID(tagName),\n    selfClosing: false,\n    ackSelfClosing: false,\n    attrs: [],\n    location: createParse5Location(node)\n  };\n\n  // The HTML parsing algorithm works by doing half of the state management in\n  // the tokenizer and half in the parser.\n  // We can’t use the tokenizer here, as we don’t have strings.\n  // So we act *as if* the tokenizer emits tokens:\n\n  // @ts-expect-error: private.\n  state.parser.currentToken = tag;\n  // @ts-expect-error: private.\n  state.parser._processToken(state.parser.currentToken);\n\n  // …but then we still need a bunch of work that the tokenizer would normally\n  // do, such as:\n\n  // Switch back to the data state after alternative states that don’t accept\n  // tags:\n  if (\n  // Current element is closed.\n  tagName === state.parser.tokenizer.lastStartTagName && (\n  // `<textarea>` and `<title>`\n  state.parser.tokenizer.state === TokenizerMode.RCDATA ||\n  // `<iframe>`, `<noembed>`, `<noframes>`, `<style>`, `<xmp>`\n  state.parser.tokenizer.state === TokenizerMode.RAWTEXT ||\n  // `<script>`\n  state.parser.tokenizer.state === TokenizerMode.SCRIPT_DATA)\n  // Note: `<plaintext>` not needed, as it’s the last element.\n  ) {\n    state.parser.tokenizer.state = TokenizerMode.DATA;\n  }\n}\n\n/**\r\n * Check if `node` represents a whole document or a fragment.\r\n *\r\n * @param {Nodes} node\r\n *   hast node.\r\n * @returns {boolean}\r\n *   Whether this represents a whole document or a fragment.\r\n */\nfunction documentMode(node) {\n  const head = node.type === 'root' ? node.children[0] : node;\n  return Boolean(head && (head.type === 'doctype' || head.type === 'element' && head.tagName.toLowerCase() === 'html'));\n}\n\n/**\r\n * Get a `parse5` location from a node.\r\n *\r\n * @param {Nodes | Stitch} node\r\n *   hast node.\r\n * @returns {Token.Location}\r\n *   `parse5` location.\r\n */\nfunction createParse5Location(node) {\n  const start = pointStart(node) || {\n    line: undefined,\n    column: undefined,\n    offset: undefined\n  };\n  const end = pointEnd(node) || {\n    line: undefined,\n    column: undefined,\n    offset: undefined\n  };\n\n  /** @type {Record<keyof Token.Location, number | undefined>} */\n  const location = {\n    startLine: start.line,\n    startCol: start.column,\n    startOffset: start.offset,\n    endLine: end.line,\n    endCol: end.column,\n    endOffset: end.offset\n  };\n\n  // @ts-expect-error: unist point values can be `undefined` in hast, which\n  // `parse5` types don’t want.\n  return location;\n}\n\n/**\r\n * @template {Nodes} NodeType\r\n *   Node type.\r\n * @param {NodeType} node\r\n *   Node to clone.\r\n * @returns {NodeType}\r\n *   Cloned node, without children.\r\n */\nfunction cloneWithoutChildren(node) {\n  return 'children' in node ? structuredClone({\n    ...node,\n    children: []\n  }) : structuredClone(node);\n}","map":{"version":3,"names":["structuredClone","fromParse5","toParse5","htmlVoidElements","Parser","Token","TokenizerMode","html","pointEnd","pointStart","visit","webNamespaces","zwitch","gfmTagfilterExpression","knownMdxNames","Set","parseOptions","sourceCodeLocationInfo","scriptingEnabled","raw","tree","options","document","documentMode","one","handlers","root","element","text","comment","doctype","handleRaw","unknown","state","parser","getFragmentParser","undefined","handle","node","stitches","resetTokenizer","p5","getFragment","result","file","index","parent","stitch","value","siblings","children","type","length","all","nodes","startTag","endTag","tokenizer","token","TokenType","CHARACTER","chars","location","createParse5Location","currentToken","_processToken","DOCTYPE","name","forceQuirks","publicId","systemId","clone","cloneWithoutChildren","fakeRoot","data","COMMENT","preprocessor","pos","lastGapPos","gapStack","skipNextNewLine","lastChunkWritten","endOfChunkHit","isEol","setPoint","write","tagfilter","replace","_runParsingLoop","cp","_consume","_callState","node_","passThrough","includes","extra","has","Error","point","currentCharacterToken","endLine","line","endCol","col","endOffset","offset","paused","inLoop","active","returnState","DATA","charRefCode","consumedAfterSnapshot","currentLocation","currentAttr","startLine","startCol","column","startOffset","lineStartPos","droppedBufferSize","tagName","toLowerCase","PLAINTEXT","current","openElements","ns","namespaceURI","svg","space","tag","START_TAG","tagID","getTagID","selfClosing","ackSelfClosing","attrs","lastStartTagName","inForeignNode","END_TAG","RCDATA","RAWTEXT","SCRIPT_DATA","head","Boolean","start","end"],"sources":["C:/Users/smart/Downloads/Final Project P20119/makeathon-2025/makeathon/node_modules/hast-util-raw/lib/index.js"],"sourcesContent":["/**\r\n * @import {Options} from 'hast-util-raw'\r\n * @import {Comment, Doctype, Element, Nodes, RootContent, Root, Text} from 'hast'\r\n * @import {Raw} from 'mdast-util-to-hast'\r\n * @import {DefaultTreeAdapterMap, ParserOptions} from 'parse5'\r\n * @import {Point} from 'unist'\r\n */\r\n\r\n/**\r\n * @typedef State\r\n *   Info passed around about the current state.\r\n * @property {(node: Nodes) => undefined} handle\r\n *   Add a hast node to the parser.\r\n * @property {Options} options\r\n *   User configuration.\r\n * @property {Parser<DefaultTreeAdapterMap>} parser\r\n *   Current parser.\r\n * @property {boolean} stitches\r\n *   Whether there are stitches.\r\n */\r\n\r\n/**\r\n * @typedef Stitch\r\n *   Custom comment-like value we pass through parse5, which contains a\r\n *   replacement node that we’ll swap back in afterwards.\r\n * @property {'comment'} type\r\n *   Node type.\r\n * @property {{stitch: Nodes}} value\r\n *   Replacement value.\r\n */\r\n\r\nimport structuredClone from '@ungap/structured-clone'\r\nimport {fromParse5} from 'hast-util-from-parse5'\r\nimport {toParse5} from 'hast-util-to-parse5'\r\nimport {htmlVoidElements} from 'html-void-elements'\r\nimport {Parser, Token, TokenizerMode, html} from 'parse5'\r\nimport {pointEnd, pointStart} from 'unist-util-position'\r\nimport {visit} from 'unist-util-visit'\r\nimport {webNamespaces} from 'web-namespaces'\r\nimport {zwitch} from 'zwitch'\r\n\r\nconst gfmTagfilterExpression =\r\n  /<(\\/?)(iframe|noembed|noframes|plaintext|script|style|textarea|title|xmp)(?=[\\t\\n\\f\\r />])/gi\r\n\r\n// Node types associated with MDX.\r\n// <https://github.com/mdx-js/mdx/blob/8a56312/packages/mdx/lib/node-types.js>\r\nconst knownMdxNames = new Set([\r\n  'mdxFlowExpression',\r\n  'mdxJsxFlowElement',\r\n  'mdxJsxTextElement',\r\n  'mdxTextExpression',\r\n  'mdxjsEsm'\r\n])\r\n\r\n/** @type {ParserOptions<DefaultTreeAdapterMap>} */\r\nconst parseOptions = {sourceCodeLocationInfo: true, scriptingEnabled: false}\r\n\r\n/**\r\n * Pass a hast tree through an HTML parser, which will fix nesting, and turn\r\n * raw nodes into actual nodes.\r\n *\r\n * @param {Nodes} tree\r\n *   Original hast tree to transform.\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration (optional).\r\n * @returns {Nodes}\r\n *   Parsed again tree.\r\n */\r\nexport function raw(tree, options) {\r\n  const document = documentMode(tree)\r\n  /** @type {(node: Nodes, state: State) => undefined} */\r\n  const one = zwitch('type', {\r\n    handlers: {root, element, text, comment, doctype, raw: handleRaw},\r\n    unknown\r\n  })\r\n\r\n  /** @type {State} */\r\n  const state = {\r\n    parser: document\r\n      ? new Parser(parseOptions)\r\n      : Parser.getFragmentParser(undefined, parseOptions),\r\n    handle(node) {\r\n      one(node, state)\r\n    },\r\n    stitches: false,\r\n    options: options || {}\r\n  }\r\n\r\n  one(tree, state)\r\n  resetTokenizer(state, pointStart())\r\n\r\n  const p5 = document ? state.parser.document : state.parser.getFragment()\r\n  const result = fromParse5(p5, {\r\n    // To do: support `space`?\r\n    file: state.options.file\r\n  })\r\n\r\n  if (state.stitches) {\r\n    visit(result, 'comment', function (node, index, parent) {\r\n      const stitch = /** @type {Stitch} */ (/** @type {unknown} */ (node))\r\n      if (stitch.value.stitch && parent && index !== undefined) {\r\n        /** @type {Array<RootContent>} */\r\n        const siblings = parent.children\r\n        // @ts-expect-error: assume the stitch is allowed.\r\n        siblings[index] = stitch.value.stitch\r\n        return index\r\n      }\r\n    })\r\n  }\r\n\r\n  // Unpack if possible and when not given a `root`.\r\n  if (\r\n    result.type === 'root' &&\r\n    result.children.length === 1 &&\r\n    result.children[0].type === tree.type\r\n  ) {\r\n    return result.children[0]\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * Transform all nodes\r\n *\r\n * @param {Array<RootContent>} nodes\r\n *   hast content.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nfunction all(nodes, state) {\r\n  let index = -1\r\n\r\n  /* istanbul ignore else - invalid nodes, see rehypejs/rehype-raw#7. */\r\n  if (nodes) {\r\n    while (++index < nodes.length) {\r\n      state.handle(nodes[index])\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Transform a root.\r\n *\r\n * @param {Root} node\r\n *   hast root node.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nfunction root(node, state) {\r\n  all(node.children, state)\r\n}\r\n\r\n/**\r\n * Transform an element.\r\n *\r\n * @param {Element} node\r\n *   hast element node.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nfunction element(node, state) {\r\n  startTag(node, state)\r\n\r\n  all(node.children, state)\r\n\r\n  endTag(node, state)\r\n}\r\n\r\n/**\r\n * Transform a text.\r\n *\r\n * @param {Text} node\r\n *   hast text node.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nfunction text(node, state) {\r\n  // Allow `DATA` through `PLAINTEXT`,\r\n  // but when hanging in a tag for example,\r\n  // switch back to `DATA`.\r\n  // Note: `State` is not exposed by `parse5`, so these numbers are fragile.\r\n  // See: <https://github.com/inikulin/parse5/blob/46cba43/packages/parse5/lib/tokenizer/index.ts#L58>\r\n  if (state.parser.tokenizer.state > 4) {\r\n    state.parser.tokenizer.state = 0\r\n  }\r\n\r\n  /** @type {Token.CharacterToken} */\r\n  const token = {\r\n    type: Token.TokenType.CHARACTER,\r\n    chars: node.value,\r\n    location: createParse5Location(node)\r\n  }\r\n\r\n  resetTokenizer(state, pointStart(node))\r\n  // @ts-expect-error: private.\r\n  state.parser.currentToken = token\r\n  // @ts-expect-error: private.\r\n  state.parser._processToken(state.parser.currentToken)\r\n}\r\n\r\n/**\r\n * Transform a doctype.\r\n *\r\n * @param {Doctype} node\r\n *   hast doctype node.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nfunction doctype(node, state) {\r\n  /** @type {Token.DoctypeToken} */\r\n  const token = {\r\n    type: Token.TokenType.DOCTYPE,\r\n    name: 'html',\r\n    forceQuirks: false,\r\n    publicId: '',\r\n    systemId: '',\r\n    location: createParse5Location(node)\r\n  }\r\n\r\n  resetTokenizer(state, pointStart(node))\r\n  // @ts-expect-error: private.\r\n  state.parser.currentToken = token\r\n  // @ts-expect-error: private.\r\n  state.parser._processToken(state.parser.currentToken)\r\n}\r\n\r\n/**\r\n * Transform a stitch.\r\n *\r\n * @param {Nodes} node\r\n *   unknown node.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nfunction stitch(node, state) {\r\n  // Mark that there are stitches, so we need to walk the tree and revert them.\r\n  state.stitches = true\r\n\r\n  /** @type {Nodes} */\r\n  const clone = cloneWithoutChildren(node)\r\n\r\n  // Recurse, because to somewhat handle `[<x>]</x>` (where `[]` denotes the\r\n  // passed through node).\r\n  if ('children' in node && 'children' in clone) {\r\n    // Root in root out.\r\n    const fakeRoot = /** @type {Root} */ (\r\n      raw({type: 'root', children: node.children}, state.options)\r\n    )\r\n    clone.children = fakeRoot.children\r\n  }\r\n\r\n  // Hack: `value` is supposed to be a string, but as none of the tools\r\n  // (`parse5` or `hast-util-from-parse5`) looks at it, we can pass nodes\r\n  // through.\r\n  comment({type: 'comment', value: {stitch: clone}}, state)\r\n}\r\n\r\n/**\r\n * Transform a comment (or stitch).\r\n *\r\n * @param {Comment | Stitch} node\r\n *   hast comment node.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nfunction comment(node, state) {\r\n  /** @type {string} */\r\n  // @ts-expect-error: we pass stitches through.\r\n  const data = node.value\r\n\r\n  /** @type {Token.CommentToken} */\r\n  const token = {\r\n    type: Token.TokenType.COMMENT,\r\n    data,\r\n    location: createParse5Location(node)\r\n  }\r\n  resetTokenizer(state, pointStart(node))\r\n  // @ts-expect-error: private.\r\n  state.parser.currentToken = token\r\n  // @ts-expect-error: private.\r\n  state.parser._processToken(state.parser.currentToken)\r\n}\r\n\r\n/**\r\n * Transform a raw node.\r\n *\r\n * @param {Raw} node\r\n *   hast raw node.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nfunction handleRaw(node, state) {\r\n  // Reset preprocessor:\r\n  // See: <https://github.com/inikulin/parse5/blob/6f7ca60/packages/parse5/lib/tokenizer/preprocessor.ts#L18-L31>.\r\n  state.parser.tokenizer.preprocessor.html = ''\r\n  state.parser.tokenizer.preprocessor.pos = -1\r\n  // @ts-expect-error: private.\r\n  // type-coverage:ignore-next-line\r\n  state.parser.tokenizer.preprocessor.lastGapPos = -2\r\n  // @ts-expect-error: private.\r\n  // type-coverage:ignore-next-line\r\n  state.parser.tokenizer.preprocessor.gapStack = []\r\n  // @ts-expect-error: private.\r\n  // type-coverage:ignore-next-line\r\n  state.parser.tokenizer.preprocessor.skipNextNewLine = false\r\n  state.parser.tokenizer.preprocessor.lastChunkWritten = false\r\n  state.parser.tokenizer.preprocessor.endOfChunkHit = false\r\n  // @ts-expect-error: private.\r\n  // type-coverage:ignore-next-line\r\n  state.parser.tokenizer.preprocessor.isEol = false\r\n\r\n  // Now pass `node.value`.\r\n  setPoint(state, pointStart(node))\r\n\r\n  state.parser.tokenizer.write(\r\n    state.options.tagfilter\r\n      ? node.value.replace(gfmTagfilterExpression, '&lt;$1$2')\r\n      : node.value,\r\n    false\r\n  )\r\n  // @ts-expect-error: private.\r\n  state.parser.tokenizer._runParsingLoop()\r\n\r\n  // Character references hang, so if we ended there, we need to flush\r\n  // those too.\r\n  // We reset the preprocessor as if the document ends here.\r\n  // Then one single call to the relevant state does the trick, parse5\r\n  // consumes the whole token.\r\n\r\n  // Note: `State` is not exposed by `parse5`, so these numbers are fragile.\r\n  // See: <https://github.com/inikulin/parse5/blob/46cba43/packages/parse5/lib/tokenizer/index.ts#L58>\r\n  // Note: a change to `parse5`, which breaks this, was merged but not released.\r\n  // Investigate when it is.\r\n  // To do: remove next major.\r\n  /* c8 ignore next 12 -- removed in <https://github.com/inikulin/parse5/pull/897> */\r\n  if (\r\n    state.parser.tokenizer.state === 72 /* NAMED_CHARACTER_REFERENCE */ ||\r\n    // @ts-expect-error: removed.\r\n    state.parser.tokenizer.state === 78 /* NUMERIC_CHARACTER_REFERENCE_END */\r\n  ) {\r\n    state.parser.tokenizer.preprocessor.lastChunkWritten = true\r\n    /** @type {number} */\r\n    // @ts-expect-error: private.\r\n    const cp = state.parser.tokenizer._consume()\r\n    // @ts-expect-error: private.\r\n    state.parser.tokenizer._callState(cp)\r\n  }\r\n}\r\n\r\n/**\r\n * Crash on an unknown node.\r\n *\r\n * @param {unknown} node_\r\n *   unknown node.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Never.\r\n */\r\nfunction unknown(node_, state) {\r\n  const node = /** @type {Nodes} */ (node_)\r\n\r\n  if (\r\n    state.options.passThrough &&\r\n    state.options.passThrough.includes(node.type)\r\n  ) {\r\n    stitch(node, state)\r\n  } else {\r\n    let extra = ''\r\n\r\n    if (knownMdxNames.has(node.type)) {\r\n      extra =\r\n        \". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax\"\r\n    }\r\n\r\n    throw new Error('Cannot compile `' + node.type + '` node' + extra)\r\n  }\r\n}\r\n\r\n/**\r\n * Reset the tokenizer of a parser.\r\n *\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @param {Point | undefined} point\r\n *   Point.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nfunction resetTokenizer(state, point) {\r\n  setPoint(state, point)\r\n\r\n  // Process final characters if they’re still there after hibernating.\r\n  /** @type {Token.CharacterToken} */\r\n  // @ts-expect-error: private.\r\n  const token = state.parser.tokenizer.currentCharacterToken\r\n\r\n  if (token && token.location) {\r\n    token.location.endLine = state.parser.tokenizer.preprocessor.line\r\n    token.location.endCol = state.parser.tokenizer.preprocessor.col + 1\r\n    token.location.endOffset = state.parser.tokenizer.preprocessor.offset + 1\r\n    // @ts-expect-error: private.\r\n    state.parser.currentToken = token\r\n    // @ts-expect-error: private.\r\n    state.parser._processToken(state.parser.currentToken)\r\n  }\r\n\r\n  // Reset tokenizer:\r\n  // See: <https://github.com/inikulin/parse5/blob/6f7ca60/packages/parse5/lib/tokenizer/index.ts#L187-L223>.\r\n  // Especially putting it back in the `data` state is useful: some elements,\r\n  // like textareas and iframes, change the state.\r\n  // See GH-7.\r\n  // But also if broken HTML is in `raw`, and then a correct element is given.\r\n  // See GH-11.\r\n  // @ts-expect-error: private.\r\n  state.parser.tokenizer.paused = false\r\n  // @ts-expect-error: private.\r\n  state.parser.tokenizer.inLoop = false\r\n\r\n  // Note: don’t reset `state`, `inForeignNode`, or `lastStartTagName`, we\r\n  // manually update those when needed.\r\n  state.parser.tokenizer.active = false\r\n  // @ts-expect-error: private.\r\n  state.parser.tokenizer.returnState = TokenizerMode.DATA\r\n  // @ts-expect-error: private.\r\n  state.parser.tokenizer.charRefCode = -1\r\n  // @ts-expect-error: private.\r\n  state.parser.tokenizer.consumedAfterSnapshot = -1\r\n  // @ts-expect-error: private.\r\n  state.parser.tokenizer.currentLocation = null\r\n  // @ts-expect-error: private.\r\n  state.parser.tokenizer.currentCharacterToken = null\r\n  // @ts-expect-error: private.\r\n  state.parser.tokenizer.currentToken = null\r\n  // @ts-expect-error: private.\r\n  state.parser.tokenizer.currentAttr = {name: '', value: ''}\r\n}\r\n\r\n/**\r\n * Set current location.\r\n *\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @param {Point | undefined} point\r\n *   Point.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nfunction setPoint(state, point) {\r\n  if (point && point.offset !== undefined) {\r\n    /** @type {Token.Location} */\r\n    const location = {\r\n      startLine: point.line,\r\n      startCol: point.column,\r\n      startOffset: point.offset,\r\n      endLine: -1,\r\n      endCol: -1,\r\n      endOffset: -1\r\n    }\r\n\r\n    // @ts-expect-error: private.\r\n    // type-coverage:ignore-next-line\r\n    state.parser.tokenizer.preprocessor.lineStartPos = -point.column + 1 // Looks weird, but ensures we get correct positional info.\r\n    state.parser.tokenizer.preprocessor.droppedBufferSize = point.offset\r\n    state.parser.tokenizer.preprocessor.line = point.line\r\n    // @ts-expect-error: private.\r\n    state.parser.tokenizer.currentLocation = location\r\n  }\r\n}\r\n\r\n/**\r\n * Emit a start tag.\r\n *\r\n * @param {Element} node\r\n *   Element.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nfunction startTag(node, state) {\r\n  const tagName = node.tagName.toLowerCase()\r\n\r\n  // Ignore tags if we’re in plain text.\r\n  if (state.parser.tokenizer.state === TokenizerMode.PLAINTEXT) return\r\n\r\n  resetTokenizer(state, pointStart(node))\r\n\r\n  const current = state.parser.openElements.current\r\n  let ns = 'namespaceURI' in current ? current.namespaceURI : webNamespaces.html\r\n\r\n  if (ns === webNamespaces.html && tagName === 'svg') {\r\n    ns = webNamespaces.svg\r\n  }\r\n\r\n  const result = toParse5(\r\n    // Shallow clone to not delve into `children`: we only need the attributes.\r\n    {...node, children: []},\r\n    {space: ns === webNamespaces.svg ? 'svg' : 'html'}\r\n  )\r\n\r\n  /** @type {Token.TagToken} */\r\n  const tag = {\r\n    type: Token.TokenType.START_TAG,\r\n    tagName,\r\n    tagID: html.getTagID(tagName),\r\n    // We always send start and end tags.\r\n    selfClosing: false,\r\n    ackSelfClosing: false,\r\n    // Always element.\r\n    /* c8 ignore next */\r\n    attrs: 'attrs' in result ? result.attrs : [],\r\n    location: createParse5Location(node)\r\n  }\r\n\r\n  // The HTML parsing algorithm works by doing half of the state management in\r\n  // the tokenizer and half in the parser.\r\n  // We can’t use the tokenizer here, as we don’t have strings.\r\n  // So we act *as if* the tokenizer emits tokens:\r\n\r\n  // @ts-expect-error: private.\r\n  state.parser.currentToken = tag\r\n  // @ts-expect-error: private.\r\n  state.parser._processToken(state.parser.currentToken)\r\n\r\n  // …but then we still need a bunch of work that the tokenizer would normally\r\n  // do, such as:\r\n\r\n  // Set a tag name, similar to how the tokenizer would do it.\r\n  state.parser.tokenizer.lastStartTagName = tagName\r\n\r\n  // `inForeignNode` is correctly set by the parser.\r\n}\r\n\r\n/**\r\n * Emit an end tag.\r\n *\r\n * @param {Element} node\r\n *   Element.\r\n * @param {State} state\r\n *   Info passed around about the current state.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nfunction endTag(node, state) {\r\n  const tagName = node.tagName.toLowerCase()\r\n  // Do not emit closing tags for HTML void elements.\r\n  if (\r\n    !state.parser.tokenizer.inForeignNode &&\r\n    htmlVoidElements.includes(tagName)\r\n  ) {\r\n    return\r\n  }\r\n\r\n  // Ignore tags if we’re in plain text.\r\n  if (state.parser.tokenizer.state === TokenizerMode.PLAINTEXT) return\r\n\r\n  resetTokenizer(state, pointEnd(node))\r\n\r\n  /** @type {Token.TagToken} */\r\n  const tag = {\r\n    type: Token.TokenType.END_TAG,\r\n    tagName,\r\n    tagID: html.getTagID(tagName),\r\n    selfClosing: false,\r\n    ackSelfClosing: false,\r\n    attrs: [],\r\n    location: createParse5Location(node)\r\n  }\r\n\r\n  // The HTML parsing algorithm works by doing half of the state management in\r\n  // the tokenizer and half in the parser.\r\n  // We can’t use the tokenizer here, as we don’t have strings.\r\n  // So we act *as if* the tokenizer emits tokens:\r\n\r\n  // @ts-expect-error: private.\r\n  state.parser.currentToken = tag\r\n  // @ts-expect-error: private.\r\n  state.parser._processToken(state.parser.currentToken)\r\n\r\n  // …but then we still need a bunch of work that the tokenizer would normally\r\n  // do, such as:\r\n\r\n  // Switch back to the data state after alternative states that don’t accept\r\n  // tags:\r\n  if (\r\n    // Current element is closed.\r\n    tagName === state.parser.tokenizer.lastStartTagName &&\r\n    // `<textarea>` and `<title>`\r\n    (state.parser.tokenizer.state === TokenizerMode.RCDATA ||\r\n      // `<iframe>`, `<noembed>`, `<noframes>`, `<style>`, `<xmp>`\r\n      state.parser.tokenizer.state === TokenizerMode.RAWTEXT ||\r\n      // `<script>`\r\n      state.parser.tokenizer.state === TokenizerMode.SCRIPT_DATA)\r\n    // Note: `<plaintext>` not needed, as it’s the last element.\r\n  ) {\r\n    state.parser.tokenizer.state = TokenizerMode.DATA\r\n  }\r\n}\r\n\r\n/**\r\n * Check if `node` represents a whole document or a fragment.\r\n *\r\n * @param {Nodes} node\r\n *   hast node.\r\n * @returns {boolean}\r\n *   Whether this represents a whole document or a fragment.\r\n */\r\nfunction documentMode(node) {\r\n  const head = node.type === 'root' ? node.children[0] : node\r\n  return Boolean(\r\n    head &&\r\n      (head.type === 'doctype' ||\r\n        (head.type === 'element' && head.tagName.toLowerCase() === 'html'))\r\n  )\r\n}\r\n\r\n/**\r\n * Get a `parse5` location from a node.\r\n *\r\n * @param {Nodes | Stitch} node\r\n *   hast node.\r\n * @returns {Token.Location}\r\n *   `parse5` location.\r\n */\r\nfunction createParse5Location(node) {\r\n  const start = pointStart(node) || {\r\n    line: undefined,\r\n    column: undefined,\r\n    offset: undefined\r\n  }\r\n  const end = pointEnd(node) || {\r\n    line: undefined,\r\n    column: undefined,\r\n    offset: undefined\r\n  }\r\n\r\n  /** @type {Record<keyof Token.Location, number | undefined>} */\r\n  const location = {\r\n    startLine: start.line,\r\n    startCol: start.column,\r\n    startOffset: start.offset,\r\n    endLine: end.line,\r\n    endCol: end.column,\r\n    endOffset: end.offset\r\n  }\r\n\r\n  // @ts-expect-error: unist point values can be `undefined` in hast, which\r\n  // `parse5` types don’t want.\r\n  return location\r\n}\r\n\r\n/**\r\n * @template {Nodes} NodeType\r\n *   Node type.\r\n * @param {NodeType} node\r\n *   Node to clone.\r\n * @returns {NodeType}\r\n *   Cloned node, without children.\r\n */\r\nfunction cloneWithoutChildren(node) {\r\n  return 'children' in node\r\n    ? structuredClone({...node, children: []})\r\n    : structuredClone(node)\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}