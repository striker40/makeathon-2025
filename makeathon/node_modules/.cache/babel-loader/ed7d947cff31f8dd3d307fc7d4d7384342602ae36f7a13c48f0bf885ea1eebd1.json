{"ast":null,"code":"/**\r\n * @import {VFile, Value} from 'vfile'\r\n * @import {Location} from 'vfile-location'\r\n */\n\n/**\r\n * Create an index of the given document to translate between line/column and\r\n * offset based positional info.\r\n *\r\n * Also implemented in Rust in [`wooorm/markdown-rs`][markdown-rs].\r\n *\r\n * [markdown-rs]: https://github.com/wooorm/markdown-rs/blob/main/src/util/location.rs\r\n *\r\n * @param {VFile | Value} file\r\n *   File to index.\r\n * @returns {Location}\r\n *   Accessors for index.\r\n */\nexport function location(file) {\n  const value = String(file);\n  /**\r\n   * List, where each index is a line number (0-based), and each value is the\r\n   * byte index *after* where the line ends.\r\n   *\r\n   * @type {Array<number>}\r\n   */\n  const indices = [];\n  return {\n    toOffset,\n    toPoint\n  };\n\n  /** @type {Location['toPoint']} */\n  function toPoint(offset) {\n    if (typeof offset === 'number' && offset > -1 && offset <= value.length) {\n      let index = 0;\n      while (true) {\n        let end = indices[index];\n        if (end === undefined) {\n          const eol = next(value, indices[index - 1]);\n          end = eol === -1 ? value.length + 1 : eol + 1;\n          indices[index] = end;\n        }\n        if (end > offset) {\n          return {\n            line: index + 1,\n            column: offset - (index > 0 ? indices[index - 1] : 0) + 1,\n            offset\n          };\n        }\n        index++;\n      }\n    }\n  }\n\n  /** @type {Location['toOffset']} */\n  function toOffset(point) {\n    if (point && typeof point.line === 'number' && typeof point.column === 'number' && !Number.isNaN(point.line) && !Number.isNaN(point.column)) {\n      while (indices.length < point.line) {\n        const from = indices[indices.length - 1];\n        const eol = next(value, from);\n        const end = eol === -1 ? value.length + 1 : eol + 1;\n        if (from === end) break;\n        indices.push(end);\n      }\n      const offset = (point.line > 1 ? indices[point.line - 2] : 0) + point.column - 1;\n      // The given `column` could not exist on this line.\n      if (offset < indices[point.line - 1]) return offset;\n    }\n  }\n}\n\n/**\r\n * @param {string} value\r\n * @param {number} from\r\n */\nfunction next(value, from) {\n  const cr = value.indexOf('\\r', from);\n  const lf = value.indexOf('\\n', from);\n  if (lf === -1) return cr;\n  if (cr === -1 || cr + 1 === lf) return lf;\n  return cr < lf ? cr : lf;\n}","map":{"version":3,"names":["location","file","value","String","indices","toOffset","toPoint","offset","length","index","end","undefined","eol","next","line","column","point","Number","isNaN","from","push","cr","indexOf","lf"],"sources":["C:/Users/smart/Downloads/Final Project P20119/makeathon-2025/makeathon/node_modules/vfile-location/lib/index.js"],"sourcesContent":["/**\r\n * @import {VFile, Value} from 'vfile'\r\n * @import {Location} from 'vfile-location'\r\n */\r\n\r\n/**\r\n * Create an index of the given document to translate between line/column and\r\n * offset based positional info.\r\n *\r\n * Also implemented in Rust in [`wooorm/markdown-rs`][markdown-rs].\r\n *\r\n * [markdown-rs]: https://github.com/wooorm/markdown-rs/blob/main/src/util/location.rs\r\n *\r\n * @param {VFile | Value} file\r\n *   File to index.\r\n * @returns {Location}\r\n *   Accessors for index.\r\n */\r\nexport function location(file) {\r\n  const value = String(file)\r\n  /**\r\n   * List, where each index is a line number (0-based), and each value is the\r\n   * byte index *after* where the line ends.\r\n   *\r\n   * @type {Array<number>}\r\n   */\r\n  const indices = []\r\n\r\n  return {toOffset, toPoint}\r\n\r\n  /** @type {Location['toPoint']} */\r\n  function toPoint(offset) {\r\n    if (typeof offset === 'number' && offset > -1 && offset <= value.length) {\r\n      let index = 0\r\n\r\n      while (true) {\r\n        let end = indices[index]\r\n\r\n        if (end === undefined) {\r\n          const eol = next(value, indices[index - 1])\r\n          end = eol === -1 ? value.length + 1 : eol + 1\r\n          indices[index] = end\r\n        }\r\n\r\n        if (end > offset) {\r\n          return {\r\n            line: index + 1,\r\n            column: offset - (index > 0 ? indices[index - 1] : 0) + 1,\r\n            offset\r\n          }\r\n        }\r\n\r\n        index++\r\n      }\r\n    }\r\n  }\r\n\r\n  /** @type {Location['toOffset']} */\r\n  function toOffset(point) {\r\n    if (\r\n      point &&\r\n      typeof point.line === 'number' &&\r\n      typeof point.column === 'number' &&\r\n      !Number.isNaN(point.line) &&\r\n      !Number.isNaN(point.column)\r\n    ) {\r\n      while (indices.length < point.line) {\r\n        const from = indices[indices.length - 1]\r\n        const eol = next(value, from)\r\n        const end = eol === -1 ? value.length + 1 : eol + 1\r\n        if (from === end) break\r\n        indices.push(end)\r\n      }\r\n\r\n      const offset =\r\n        (point.line > 1 ? indices[point.line - 2] : 0) + point.column - 1\r\n      // The given `column` could not exist on this line.\r\n      if (offset < indices[point.line - 1]) return offset\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {string} value\r\n * @param {number} from\r\n */\r\nfunction next(value, from) {\r\n  const cr = value.indexOf('\\r', from)\r\n  const lf = value.indexOf('\\n', from)\r\n  if (lf === -1) return cr\r\n  if (cr === -1 || cr + 1 === lf) return lf\r\n  return cr < lf ? cr : lf\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,QAAQA,CAACC,IAAI,EAAE;EAC7B,MAAMC,KAAK,GAAGC,MAAM,CAACF,IAAI,CAAC;EAC1B;AACF;AACA;AACA;AACA;AACA;EACE,MAAMG,OAAO,GAAG,EAAE;EAElB,OAAO;IAACC,QAAQ;IAAEC;EAAO,CAAC;;EAE1B;EACA,SAASA,OAAOA,CAACC,MAAM,EAAE;IACvB,IAAI,OAAOA,MAAM,KAAK,QAAQ,IAAIA,MAAM,GAAG,CAAC,CAAC,IAAIA,MAAM,IAAIL,KAAK,CAACM,MAAM,EAAE;MACvE,IAAIC,KAAK,GAAG,CAAC;MAEb,OAAO,IAAI,EAAE;QACX,IAAIC,GAAG,GAAGN,OAAO,CAACK,KAAK,CAAC;QAExB,IAAIC,GAAG,KAAKC,SAAS,EAAE;UACrB,MAAMC,GAAG,GAAGC,IAAI,CAACX,KAAK,EAAEE,OAAO,CAACK,KAAK,GAAG,CAAC,CAAC,CAAC;UAC3CC,GAAG,GAAGE,GAAG,KAAK,CAAC,CAAC,GAAGV,KAAK,CAACM,MAAM,GAAG,CAAC,GAAGI,GAAG,GAAG,CAAC;UAC7CR,OAAO,CAACK,KAAK,CAAC,GAAGC,GAAG;QACtB;QAEA,IAAIA,GAAG,GAAGH,MAAM,EAAE;UAChB,OAAO;YACLO,IAAI,EAAEL,KAAK,GAAG,CAAC;YACfM,MAAM,EAAER,MAAM,IAAIE,KAAK,GAAG,CAAC,GAAGL,OAAO,CAACK,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;YACzDF;UACF,CAAC;QACH;QAEAE,KAAK,EAAE;MACT;IACF;EACF;;EAEA;EACA,SAASJ,QAAQA,CAACW,KAAK,EAAE;IACvB,IACEA,KAAK,IACL,OAAOA,KAAK,CAACF,IAAI,KAAK,QAAQ,IAC9B,OAAOE,KAAK,CAACD,MAAM,KAAK,QAAQ,IAChC,CAACE,MAAM,CAACC,KAAK,CAACF,KAAK,CAACF,IAAI,CAAC,IACzB,CAACG,MAAM,CAACC,KAAK,CAACF,KAAK,CAACD,MAAM,CAAC,EAC3B;MACA,OAAOX,OAAO,CAACI,MAAM,GAAGQ,KAAK,CAACF,IAAI,EAAE;QAClC,MAAMK,IAAI,GAAGf,OAAO,CAACA,OAAO,CAACI,MAAM,GAAG,CAAC,CAAC;QACxC,MAAMI,GAAG,GAAGC,IAAI,CAACX,KAAK,EAAEiB,IAAI,CAAC;QAC7B,MAAMT,GAAG,GAAGE,GAAG,KAAK,CAAC,CAAC,GAAGV,KAAK,CAACM,MAAM,GAAG,CAAC,GAAGI,GAAG,GAAG,CAAC;QACnD,IAAIO,IAAI,KAAKT,GAAG,EAAE;QAClBN,OAAO,CAACgB,IAAI,CAACV,GAAG,CAAC;MACnB;MAEA,MAAMH,MAAM,GACV,CAACS,KAAK,CAACF,IAAI,GAAG,CAAC,GAAGV,OAAO,CAACY,KAAK,CAACF,IAAI,GAAG,CAAC,CAAC,GAAG,CAAC,IAAIE,KAAK,CAACD,MAAM,GAAG,CAAC;MACnE;MACA,IAAIR,MAAM,GAAGH,OAAO,CAACY,KAAK,CAACF,IAAI,GAAG,CAAC,CAAC,EAAE,OAAOP,MAAM;IACrD;EACF;AACF;;AAEA;AACA;AACA;AACA;AACA,SAASM,IAAIA,CAACX,KAAK,EAAEiB,IAAI,EAAE;EACzB,MAAME,EAAE,GAAGnB,KAAK,CAACoB,OAAO,CAAC,IAAI,EAAEH,IAAI,CAAC;EACpC,MAAMI,EAAE,GAAGrB,KAAK,CAACoB,OAAO,CAAC,IAAI,EAAEH,IAAI,CAAC;EACpC,IAAII,EAAE,KAAK,CAAC,CAAC,EAAE,OAAOF,EAAE;EACxB,IAAIA,EAAE,KAAK,CAAC,CAAC,IAAIA,EAAE,GAAG,CAAC,KAAKE,EAAE,EAAE,OAAOA,EAAE;EACzC,OAAOF,EAAE,GAAGE,EAAE,GAAGF,EAAE,GAAGE,EAAE;AAC1B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}