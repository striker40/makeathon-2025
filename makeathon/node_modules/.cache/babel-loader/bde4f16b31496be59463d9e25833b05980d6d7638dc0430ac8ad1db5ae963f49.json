{"ast":null,"code":"/**\r\n * @typedef {import('hast').Element} Element\r\n * @typedef {import('hast').Properties} Properties\r\n */\n\n/**\r\n * @template {string} SimpleSelector\r\n *   Selector type.\r\n * @template {string} DefaultTagName\r\n *   Default tag name.\r\n * @typedef {(\r\n *   SimpleSelector extends ''\r\n *     ? DefaultTagName\r\n *     : SimpleSelector extends `${infer TagName}.${infer Rest}`\r\n *     ? ExtractTagName<TagName, DefaultTagName>\r\n *     : SimpleSelector extends `${infer TagName}#${infer Rest}`\r\n *     ? ExtractTagName<TagName, DefaultTagName>\r\n *     : SimpleSelector extends string\r\n *     ? SimpleSelector\r\n *     : DefaultTagName\r\n * )} ExtractTagName\r\n *   Extract tag name from a simple selector.\r\n */\n\nconst search = /[#.]/g;\n\n/**\r\n * Create a hast element from a simple CSS selector.\r\n *\r\n * @template {string} Selector\r\n *   Type of selector.\r\n * @template {string} [DefaultTagName='div']\r\n *   Type of default tag name (default: `'div'`).\r\n * @param {Selector | null | undefined} [selector]\r\n *   Simple CSS selector (optional).\r\n *\r\n *   Can contain a tag name (`foo`), classes (`.bar`), and an ID (`#baz`).\r\n *   Multiple classes are allowed.\r\n *   Uses the last ID if multiple IDs are found.\r\n * @param {DefaultTagName | null | undefined} [defaultTagName='div']\r\n *   Tag name to use if `selector` does not specify one (default: `'div'`).\r\n * @returns {Element & {tagName: ExtractTagName<Selector, DefaultTagName>}}\r\n *   Built element.\r\n */\nexport function parseSelector(selector, defaultTagName) {\n  const value = selector || '';\n  /** @type {Properties} */\n  const props = {};\n  let start = 0;\n  /** @type {string | undefined} */\n  let previous;\n  /** @type {string | undefined} */\n  let tagName;\n  while (start < value.length) {\n    search.lastIndex = start;\n    const match = search.exec(value);\n    const subvalue = value.slice(start, match ? match.index : value.length);\n    if (subvalue) {\n      if (!previous) {\n        tagName = subvalue;\n      } else if (previous === '#') {\n        props.id = subvalue;\n      } else if (Array.isArray(props.className)) {\n        props.className.push(subvalue);\n      } else {\n        props.className = [subvalue];\n      }\n      start += subvalue.length;\n    }\n    if (match) {\n      previous = match[0];\n      start++;\n    }\n  }\n  return {\n    type: 'element',\n    // @ts-expect-error: tag name is parsed.\n    tagName: tagName || defaultTagName || 'div',\n    properties: props,\n    children: []\n  };\n}","map":{"version":3,"names":["search","parseSelector","selector","defaultTagName","value","props","start","previous","tagName","length","lastIndex","match","exec","subvalue","slice","index","id","Array","isArray","className","push","type","properties","children"],"sources":["C:/Users/smart/Downloads/Final Project P20119/makeathon-2025/makeathon/node_modules/hast-util-parse-selector/lib/index.js"],"sourcesContent":["/**\r\n * @typedef {import('hast').Element} Element\r\n * @typedef {import('hast').Properties} Properties\r\n */\r\n\r\n/**\r\n * @template {string} SimpleSelector\r\n *   Selector type.\r\n * @template {string} DefaultTagName\r\n *   Default tag name.\r\n * @typedef {(\r\n *   SimpleSelector extends ''\r\n *     ? DefaultTagName\r\n *     : SimpleSelector extends `${infer TagName}.${infer Rest}`\r\n *     ? ExtractTagName<TagName, DefaultTagName>\r\n *     : SimpleSelector extends `${infer TagName}#${infer Rest}`\r\n *     ? ExtractTagName<TagName, DefaultTagName>\r\n *     : SimpleSelector extends string\r\n *     ? SimpleSelector\r\n *     : DefaultTagName\r\n * )} ExtractTagName\r\n *   Extract tag name from a simple selector.\r\n */\r\n\r\nconst search = /[#.]/g\r\n\r\n/**\r\n * Create a hast element from a simple CSS selector.\r\n *\r\n * @template {string} Selector\r\n *   Type of selector.\r\n * @template {string} [DefaultTagName='div']\r\n *   Type of default tag name (default: `'div'`).\r\n * @param {Selector | null | undefined} [selector]\r\n *   Simple CSS selector (optional).\r\n *\r\n *   Can contain a tag name (`foo`), classes (`.bar`), and an ID (`#baz`).\r\n *   Multiple classes are allowed.\r\n *   Uses the last ID if multiple IDs are found.\r\n * @param {DefaultTagName | null | undefined} [defaultTagName='div']\r\n *   Tag name to use if `selector` does not specify one (default: `'div'`).\r\n * @returns {Element & {tagName: ExtractTagName<Selector, DefaultTagName>}}\r\n *   Built element.\r\n */\r\nexport function parseSelector(selector, defaultTagName) {\r\n  const value = selector || ''\r\n  /** @type {Properties} */\r\n  const props = {}\r\n  let start = 0\r\n  /** @type {string | undefined} */\r\n  let previous\r\n  /** @type {string | undefined} */\r\n  let tagName\r\n\r\n  while (start < value.length) {\r\n    search.lastIndex = start\r\n    const match = search.exec(value)\r\n    const subvalue = value.slice(start, match ? match.index : value.length)\r\n\r\n    if (subvalue) {\r\n      if (!previous) {\r\n        tagName = subvalue\r\n      } else if (previous === '#') {\r\n        props.id = subvalue\r\n      } else if (Array.isArray(props.className)) {\r\n        props.className.push(subvalue)\r\n      } else {\r\n        props.className = [subvalue]\r\n      }\r\n\r\n      start += subvalue.length\r\n    }\r\n\r\n    if (match) {\r\n      previous = match[0]\r\n      start++\r\n    }\r\n  }\r\n\r\n  return {\r\n    type: 'element',\r\n    // @ts-expect-error: tag name is parsed.\r\n    tagName: tagName || defaultTagName || 'div',\r\n    properties: props,\r\n    children: []\r\n  }\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,MAAM,GAAG,OAAO;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,aAAaA,CAACC,QAAQ,EAAEC,cAAc,EAAE;EACtD,MAAMC,KAAK,GAAGF,QAAQ,IAAI,EAAE;EAC5B;EACA,MAAMG,KAAK,GAAG,CAAC,CAAC;EAChB,IAAIC,KAAK,GAAG,CAAC;EACb;EACA,IAAIC,QAAQ;EACZ;EACA,IAAIC,OAAO;EAEX,OAAOF,KAAK,GAAGF,KAAK,CAACK,MAAM,EAAE;IAC3BT,MAAM,CAACU,SAAS,GAAGJ,KAAK;IACxB,MAAMK,KAAK,GAAGX,MAAM,CAACY,IAAI,CAACR,KAAK,CAAC;IAChC,MAAMS,QAAQ,GAAGT,KAAK,CAACU,KAAK,CAACR,KAAK,EAAEK,KAAK,GAAGA,KAAK,CAACI,KAAK,GAAGX,KAAK,CAACK,MAAM,CAAC;IAEvE,IAAII,QAAQ,EAAE;MACZ,IAAI,CAACN,QAAQ,EAAE;QACbC,OAAO,GAAGK,QAAQ;MACpB,CAAC,MAAM,IAAIN,QAAQ,KAAK,GAAG,EAAE;QAC3BF,KAAK,CAACW,EAAE,GAAGH,QAAQ;MACrB,CAAC,MAAM,IAAII,KAAK,CAACC,OAAO,CAACb,KAAK,CAACc,SAAS,CAAC,EAAE;QACzCd,KAAK,CAACc,SAAS,CAACC,IAAI,CAACP,QAAQ,CAAC;MAChC,CAAC,MAAM;QACLR,KAAK,CAACc,SAAS,GAAG,CAACN,QAAQ,CAAC;MAC9B;MAEAP,KAAK,IAAIO,QAAQ,CAACJ,MAAM;IAC1B;IAEA,IAAIE,KAAK,EAAE;MACTJ,QAAQ,GAAGI,KAAK,CAAC,CAAC,CAAC;MACnBL,KAAK,EAAE;IACT;EACF;EAEA,OAAO;IACLe,IAAI,EAAE,SAAS;IACf;IACAb,OAAO,EAAEA,OAAO,IAAIL,cAAc,IAAI,KAAK;IAC3CmB,UAAU,EAAEjB,KAAK;IACjBkB,QAAQ,EAAE;EACZ,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}