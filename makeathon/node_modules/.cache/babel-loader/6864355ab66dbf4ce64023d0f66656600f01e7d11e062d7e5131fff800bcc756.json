{"ast":null,"code":"/**\r\n * @typedef {import('hast').Comment} Comment\r\n * @typedef {import('hast').Element} Element\r\n * @typedef {import('hast').Nodes} Nodes\r\n * @typedef {import('hast').Parents} Parents\r\n * @typedef {import('hast').Text} Text\r\n * @typedef {import('hast-util-is-element').TestFunction} TestFunction\r\n */\n\n/**\r\n * @typedef {'normal' | 'nowrap' | 'pre' | 'pre-wrap'} Whitespace\r\n *   Valid and useful whitespace values (from CSS).\r\n *\r\n * @typedef {0 | 1 | 2} BreakNumber\r\n *   Specific break:\r\n *\r\n *   *   `0` — space\r\n *   *   `1` — line ending\r\n *   *   `2` — blank line\r\n *\r\n * @typedef {'\\n'} BreakForce\r\n *   Forced break.\r\n *\r\n * @typedef {boolean} BreakValue\r\n *   Whether there was a break.\r\n *\r\n * @typedef {BreakNumber | BreakValue | undefined} BreakBefore\r\n *   Any value for a break before.\r\n *\r\n * @typedef {BreakForce | BreakNumber | BreakValue | undefined} BreakAfter\r\n *   Any value for a break after.\r\n *\r\n * @typedef CollectionInfo\r\n *   Info on current collection.\r\n * @property {BreakAfter} breakAfter\r\n *   Whether there was a break after.\r\n * @property {BreakBefore} breakBefore\r\n *   Whether there was a break before.\r\n * @property {Whitespace} whitespace\r\n *   Current whitespace setting.\r\n *\r\n * @typedef Options\r\n *   Configuration.\r\n * @property {Whitespace | null | undefined} [whitespace='normal']\r\n *   Initial CSS whitespace setting to use (default: `'normal'`).\r\n */\n\nimport { findAfter } from 'unist-util-find-after';\nimport { convertElement } from 'hast-util-is-element';\nconst searchLineFeeds = /\\n/g;\nconst searchTabOrSpaces = /[\\t ]+/g;\nconst br = convertElement('br');\nconst cell = convertElement(isCell);\nconst p = convertElement('p');\nconst row = convertElement('tr');\n\n// Note that we don’t need to include void elements here as they don’t have text.\n// See: <https://github.com/wooorm/html-void-elements>\nconst notRendered = convertElement([\n// List from: <https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements>\n'datalist', 'head', 'noembed', 'noframes', 'noscript',\n// Act as if we support scripting.\n'rp', 'script', 'style', 'template', 'title',\n// Hidden attribute.\nhidden,\n// From: <https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3>\nclosedDialog]);\n\n// See: <https://html.spec.whatwg.org/multipage/rendering.html#the-css-user-agent-style-sheet-and-presentational-hints>\nconst blockOrCaption = convertElement(['address',\n// Flow content\n'article',\n// Sections and headings\n'aside',\n// Sections and headings\n'blockquote',\n// Flow content\n'body',\n// Page\n'caption',\n// `table-caption`\n'center',\n// Flow content (legacy)\n'dd',\n// Lists\n'dialog',\n// Flow content\n'dir',\n// Lists (legacy)\n'dl',\n// Lists\n'dt',\n// Lists\n'div',\n// Flow content\n'figure',\n// Flow content\n'figcaption',\n// Flow content\n'footer',\n// Flow content\n'form,',\n// Flow content\n'h1',\n// Sections and headings\n'h2',\n// Sections and headings\n'h3',\n// Sections and headings\n'h4',\n// Sections and headings\n'h5',\n// Sections and headings\n'h6',\n// Sections and headings\n'header',\n// Flow content\n'hgroup',\n// Sections and headings\n'hr',\n// Flow content\n'html',\n// Page\n'legend',\n// Flow content\n'li',\n// Lists (as `display: list-item`)\n'listing',\n// Flow content (legacy)\n'main',\n// Flow content\n'menu',\n// Lists\n'nav',\n// Sections and headings\n'ol',\n// Lists\n'p',\n// Flow content\n'plaintext',\n// Flow content (legacy)\n'pre',\n// Flow content\n'section',\n// Sections and headings\n'ul',\n// Lists\n'xmp' // Flow content (legacy)\n]);\n\n/**\r\n * Get the plain-text value of a node.\r\n *\r\n * ###### Algorithm\r\n *\r\n * *   if `tree` is a comment, returns its `value`\r\n * *   if `tree` is a text, applies normal whitespace collapsing to its\r\n *     `value`, as defined by the CSS Text spec\r\n * *   if `tree` is a root or element, applies an algorithm similar to the\r\n *     `innerText` getter as defined by HTML\r\n *\r\n * ###### Notes\r\n *\r\n * > 👉 **Note**: the algorithm acts as if `tree` is being rendered, and as if\r\n * > we’re a CSS-supporting user agent, with scripting enabled.\r\n *\r\n * *   if `tree` is an element that is not displayed (such as a `head`), we’ll\r\n *     still use the `innerText` algorithm instead of switching to `textContent`\r\n * *   if descendants of `tree` are elements that are not displayed, they are\r\n *     ignored\r\n * *   CSS is not considered, except for the default user agent style sheet\r\n * *   a line feed is collapsed instead of ignored in cases where Fullwidth, Wide,\r\n *     or Halfwidth East Asian Width characters are used, the same goes for a case\r\n *     with Chinese, Japanese, or Yi writing systems\r\n * *   replaced elements (such as `audio`) are treated like non-replaced elements\r\n *\r\n * @param {Nodes} tree\r\n *   Tree to turn into text.\r\n * @param {Readonly<Options> | null | undefined} [options]\r\n *   Configuration (optional).\r\n * @returns {string}\r\n *   Serialized `tree`.\r\n */\nexport function toText(tree, options) {\n  const options_ = options || {};\n  const children = 'children' in tree ? tree.children : [];\n  const block = blockOrCaption(tree);\n  const whitespace = inferWhitespace(tree, {\n    whitespace: options_.whitespace || 'normal',\n    breakBefore: false,\n    breakAfter: false\n  });\n\n  /** @type {Array<BreakNumber | string>} */\n  const results = [];\n\n  // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the node’s `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n  if (tree.type === 'text' || tree.type === 'comment') {\n    results.push(...collectText(tree, {\n      whitespace,\n      breakBefore: true,\n      breakAfter: true\n    }));\n  }\n\n  // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: we’re not supporting stylesheets so we’re acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: we’ll have to account for this later though.\n\n  // 2.  Let results be a new empty list.\n  let index = -1;\n\n  // 3.  For each child node node of this element:\n  while (++index < children.length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    // 3.2. For each item item in current, append item to results.\n    results.push(...renderedTextCollection(children[index],\n    // @ts-expect-error: `tree` is a parent if we’re here.\n    tree, {\n      whitespace,\n      breakBefore: index ? undefined : block,\n      breakAfter: index < children.length - 1 ? br(children[index + 1]) : block\n    }));\n  }\n\n  // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n  /** @type {Array<string>} */\n  const result = [];\n  /** @type {number | undefined} */\n  let count;\n  index = -1;\n  while (++index < results.length) {\n    const value = results[index];\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) count = value;\n    } else if (value) {\n      if (count !== undefined && count > -1) {\n        result.push('\\n'.repeat(count) || ' ');\n      }\n      count = -1;\n      result.push(value);\n    }\n  }\n\n  // 7.  Return the concatenation of the string items in results.\n  return result.join('');\n}\n\n/**\r\n * <https://html.spec.whatwg.org/multipage/dom.html#rendered-text-collection-steps>\r\n *\r\n * @param {Nodes} node\r\n * @param {Parents} parent\r\n * @param {CollectionInfo} info\r\n * @returns {Array<BreakNumber | string>}\r\n */\nfunction renderedTextCollection(node, parent, info) {\n  if (node.type === 'element') {\n    return collectElement(node, parent, info);\n  }\n  if (node.type === 'text') {\n    return info.whitespace === 'normal' ? collectText(node, info) : collectPreText(node);\n  }\n  return [];\n}\n\n/**\r\n * Collect an element.\r\n *\r\n * @param {Element} node\r\n *   Element node.\r\n * @param {Parents} parent\r\n * @param {CollectionInfo} info\r\n *   Info on current collection.\r\n * @returns {Array<BreakNumber | string>}\r\n */\nfunction collectElement(node, parent, info) {\n  // First we infer the `white-space` property.\n  const whitespace = inferWhitespace(node, info);\n  const children = node.children || [];\n  let index = -1;\n  /** @type {Array<BreakNumber | string>} */\n  let items = [];\n\n  // We’re ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n  if (notRendered(node)) {\n    return items;\n  }\n\n  /** @type {BreakNumber | undefined} */\n  let prefix;\n  /** @type {BreakForce | BreakNumber | undefined} */\n  let suffix;\n  // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n\n  // 2.  If node’s computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n\n  // See `collectText` for step 4.\n\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n  if (br(node)) {\n    suffix = '\\n';\n  }\n\n  // 7.  If node’s computed value of `display` is `table-row`, and node’s CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/multipage/rendering.html#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (row(node) &&\n  // @ts-expect-error: something up with types of parents.\n  findAfter(parent, node, row)) {\n    suffix = '\\n';\n  }\n\n  // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (p(node)) {\n    prefix = 2;\n    suffix = 2;\n  }\n\n  // 9.  If node’s used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1;\n    suffix = 1;\n  }\n\n  // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n  while (++index < children.length) {\n    items = items.concat(renderedTextCollection(children[index], node, {\n      whitespace,\n      breakBefore: index ? undefined : prefix,\n      breakAfter: index < children.length - 1 ? br(children[index + 1]) : suffix\n    }));\n  }\n\n  // 6.  If node’s computed value of `display` is `table-cell`, and node’s CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/multipage/rendering.html#tables-2>\n  if (cell(node) &&\n  // @ts-expect-error: something up with types of parents.\n  findAfter(parent, node, cell)) {\n    items.push('\\t');\n  }\n\n  // Add the pre- and suffix.\n  if (prefix) items.unshift(prefix);\n  if (suffix) items.push(suffix);\n  return items;\n}\n\n/**\r\n * 4.  If node is a Text node, then for each CSS text box produced by node,\r\n *     in content order, compute the text of the box after application of the\r\n *     CSS `white-space` processing rules and `text-transform` rules, set\r\n *     items to the list of the resulting strings, and return items.\r\n *     The CSS `white-space` processing rules are slightly modified:\r\n *     collapsible spaces at the end of lines are always collapsed, but they\r\n *     are only removed if the line is the last line of the block, or it ends\r\n *     with a br element.\r\n *     Soft hyphens should be preserved.\r\n *\r\n *     Note: See `collectText` and `collectPreText`.\r\n *     Note: we don’t deal with `text-transform`, no element has that by\r\n *     default.\r\n *\r\n * See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\r\n *\r\n * @param {Comment | Text} node\r\n *   Text node.\r\n * @param {CollectionInfo} info\r\n *   Info on current collection.\r\n * @returns {Array<BreakNumber | string>}\r\n *   Result.\r\n */\nfunction collectText(node, info) {\n  const value = String(node.value);\n  /** @type {Array<string>} */\n  const lines = [];\n  /** @type {Array<BreakNumber | string>} */\n  const result = [];\n  let start = 0;\n  while (start <= value.length) {\n    searchLineFeeds.lastIndex = start;\n    const match = searchLineFeeds.exec(value);\n    const end = match && 'index' in match ? match.index : value.length;\n    lines.push(\n    // Any sequence of collapsible spaces and tabs immediately preceding or\n    // following a segment break is removed.\n    trimAndCollapseSpacesAndTabs(\n    // […] ignoring bidi formatting characters (characters with the\n    // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\n    // they were not there.\n    value.slice(start, end).replace(/[\\u061C\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]/g, ''), start === 0 ? info.breakBefore : true, end === value.length ? info.breakAfter : true));\n    start = end + 1;\n  }\n\n  // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n  let index = -1;\n  /** @type {BreakNumber | undefined} */\n  let join;\n  while (++index < lines.length) {\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (lines[index].charCodeAt(lines[index].length - 1) === 0x20_0b /* ZWSP */ || index < lines.length - 1 && lines[index + 1].charCodeAt(0) === 0x20_0b /* ZWSP */) {\n      result.push(lines[index]);\n      join = undefined;\n    }\n\n    // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    else if (lines[index]) {\n      if (typeof join === 'number') result.push(join);\n      result.push(lines[index]);\n      join = 0;\n    } else if (index === 0 || index === lines.length - 1) {\n      // If this line is empty, and it’s the first or last, add a space.\n      // Note that this function is only called in normal whitespace, so we\n      // don’t worry about `pre`.\n      result.push(0);\n    }\n  }\n  return result;\n}\n\n/**\r\n * Collect a text node as “pre” whitespace.\r\n *\r\n * @param {Text} node\r\n *   Text node.\r\n * @returns {Array<BreakNumber | string>}\r\n *   Result.\r\n */\nfunction collectPreText(node) {\n  return [String(node.value)];\n}\n\n/**\r\n * 3.  Every collapsible tab is converted to a collapsible space (U+0020).\r\n * 4.  Any collapsible space immediately following another collapsible\r\n *     space—even one outside the boundary of the inline containing that\r\n *     space, provided both spaces are within the same inline formatting\r\n *     context—is collapsed to have zero advance width. (It is invisible,\r\n *     but retains its soft wrap opportunity, if any.)\r\n *\r\n * @param {string} value\r\n *   Value to collapse.\r\n * @param {BreakBefore} breakBefore\r\n *   Whether there was a break before.\r\n * @param {BreakAfter} breakAfter\r\n *   Whether there was a break after.\r\n * @returns {string}\r\n *   Result.\r\n */\nfunction trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  /** @type {Array<string>} */\n  const result = [];\n  let start = 0;\n  /** @type {number | undefined} */\n  let end;\n  while (start < value.length) {\n    searchTabOrSpaces.lastIndex = start;\n    const match = searchTabOrSpaces.exec(value);\n    end = match ? match.index : value.length;\n\n    // If we’re not directly after a segment break, but there was white space,\n    // add an empty value that will be turned into a space.\n    if (!start && !end && match && !breakBefore) {\n      result.push('');\n    }\n    if (start !== end) {\n      result.push(value.slice(start, end));\n    }\n    start = match ? end + match[0].length : end;\n  }\n\n  // If we reached the end, there was trailing white space, and there’s no\n  // segment break after this node, add an empty value that will be turned\n  // into a space.\n  if (start !== end && !breakAfter) {\n    result.push('');\n  }\n  return result.join(' ');\n}\n\n/**\r\n * Figure out the whitespace of a node.\r\n *\r\n * We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\r\n *\r\n * @param {Nodes} node\r\n *   Node (typically `Element`).\r\n * @param {CollectionInfo} info\r\n *   Info on current collection.\r\n * @returns {Whitespace}\r\n *   Applied whitespace.\r\n */\nfunction inferWhitespace(node, info) {\n  if (node.type === 'element') {\n    const properties = node.properties || {};\n    switch (node.tagName) {\n      case 'listing':\n      case 'plaintext':\n      case 'xmp':\n        {\n          return 'pre';\n        }\n      case 'nobr':\n        {\n          return 'nowrap';\n        }\n      case 'pre':\n        {\n          return properties.wrap ? 'pre-wrap' : 'pre';\n        }\n      case 'td':\n      case 'th':\n        {\n          return properties.noWrap ? 'nowrap' : info.whitespace;\n        }\n      case 'textarea':\n        {\n          return 'pre-wrap';\n        }\n      default:\n    }\n  }\n  return info.whitespace;\n}\n\n/**\r\n * @type {TestFunction}\r\n * @param {Element} node\r\n * @returns {node is {properties: {hidden: true}}}\r\n */\nfunction hidden(node) {\n  return Boolean((node.properties || {}).hidden);\n}\n\n/**\r\n * @type {TestFunction}\r\n * @param {Element} node\r\n * @returns {node is {tagName: 'td' | 'th'}}\r\n */\nfunction isCell(node) {\n  return node.tagName === 'td' || node.tagName === 'th';\n}\n\n/**\r\n * @type {TestFunction}\r\n */\nfunction closedDialog(node) {\n  return node.tagName === 'dialog' && !(node.properties || {}).open;\n}","map":{"version":3,"names":["findAfter","convertElement","searchLineFeeds","searchTabOrSpaces","br","cell","isCell","p","row","notRendered","hidden","closedDialog","blockOrCaption","toText","tree","options","options_","children","block","whitespace","inferWhitespace","breakBefore","breakAfter","results","type","push","collectText","index","length","renderedTextCollection","undefined","result","count","value","repeat","join","node","parent","info","collectElement","collectPreText","items","prefix","suffix","concat","unshift","String","lines","start","lastIndex","match","exec","end","trimAndCollapseSpacesAndTabs","slice","replace","charCodeAt","properties","tagName","wrap","noWrap","Boolean","open"],"sources":["C:/Users/smart/Downloads/Final Project P20119/makeathon-2025/makeathon/node_modules/hast-util-to-text/lib/index.js"],"sourcesContent":["/**\r\n * @typedef {import('hast').Comment} Comment\r\n * @typedef {import('hast').Element} Element\r\n * @typedef {import('hast').Nodes} Nodes\r\n * @typedef {import('hast').Parents} Parents\r\n * @typedef {import('hast').Text} Text\r\n * @typedef {import('hast-util-is-element').TestFunction} TestFunction\r\n */\r\n\r\n/**\r\n * @typedef {'normal' | 'nowrap' | 'pre' | 'pre-wrap'} Whitespace\r\n *   Valid and useful whitespace values (from CSS).\r\n *\r\n * @typedef {0 | 1 | 2} BreakNumber\r\n *   Specific break:\r\n *\r\n *   *   `0` — space\r\n *   *   `1` — line ending\r\n *   *   `2` — blank line\r\n *\r\n * @typedef {'\\n'} BreakForce\r\n *   Forced break.\r\n *\r\n * @typedef {boolean} BreakValue\r\n *   Whether there was a break.\r\n *\r\n * @typedef {BreakNumber | BreakValue | undefined} BreakBefore\r\n *   Any value for a break before.\r\n *\r\n * @typedef {BreakForce | BreakNumber | BreakValue | undefined} BreakAfter\r\n *   Any value for a break after.\r\n *\r\n * @typedef CollectionInfo\r\n *   Info on current collection.\r\n * @property {BreakAfter} breakAfter\r\n *   Whether there was a break after.\r\n * @property {BreakBefore} breakBefore\r\n *   Whether there was a break before.\r\n * @property {Whitespace} whitespace\r\n *   Current whitespace setting.\r\n *\r\n * @typedef Options\r\n *   Configuration.\r\n * @property {Whitespace | null | undefined} [whitespace='normal']\r\n *   Initial CSS whitespace setting to use (default: `'normal'`).\r\n */\r\n\r\nimport {findAfter} from 'unist-util-find-after'\r\nimport {convertElement} from 'hast-util-is-element'\r\n\r\nconst searchLineFeeds = /\\n/g\r\nconst searchTabOrSpaces = /[\\t ]+/g\r\n\r\nconst br = convertElement('br')\r\nconst cell = convertElement(isCell)\r\nconst p = convertElement('p')\r\nconst row = convertElement('tr')\r\n\r\n// Note that we don’t need to include void elements here as they don’t have text.\r\n// See: <https://github.com/wooorm/html-void-elements>\r\nconst notRendered = convertElement([\r\n  // List from: <https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements>\r\n  'datalist',\r\n  'head',\r\n  'noembed',\r\n  'noframes',\r\n  'noscript', // Act as if we support scripting.\r\n  'rp',\r\n  'script',\r\n  'style',\r\n  'template',\r\n  'title',\r\n  // Hidden attribute.\r\n  hidden,\r\n  // From: <https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3>\r\n  closedDialog\r\n])\r\n\r\n// See: <https://html.spec.whatwg.org/multipage/rendering.html#the-css-user-agent-style-sheet-and-presentational-hints>\r\nconst blockOrCaption = convertElement([\r\n  'address', // Flow content\r\n  'article', // Sections and headings\r\n  'aside', // Sections and headings\r\n  'blockquote', // Flow content\r\n  'body', // Page\r\n  'caption', // `table-caption`\r\n  'center', // Flow content (legacy)\r\n  'dd', // Lists\r\n  'dialog', // Flow content\r\n  'dir', // Lists (legacy)\r\n  'dl', // Lists\r\n  'dt', // Lists\r\n  'div', // Flow content\r\n  'figure', // Flow content\r\n  'figcaption', // Flow content\r\n  'footer', // Flow content\r\n  'form,', // Flow content\r\n  'h1', // Sections and headings\r\n  'h2', // Sections and headings\r\n  'h3', // Sections and headings\r\n  'h4', // Sections and headings\r\n  'h5', // Sections and headings\r\n  'h6', // Sections and headings\r\n  'header', // Flow content\r\n  'hgroup', // Sections and headings\r\n  'hr', // Flow content\r\n  'html', // Page\r\n  'legend', // Flow content\r\n  'li', // Lists (as `display: list-item`)\r\n  'listing', // Flow content (legacy)\r\n  'main', // Flow content\r\n  'menu', // Lists\r\n  'nav', // Sections and headings\r\n  'ol', // Lists\r\n  'p', // Flow content\r\n  'plaintext', // Flow content (legacy)\r\n  'pre', // Flow content\r\n  'section', // Sections and headings\r\n  'ul', // Lists\r\n  'xmp' // Flow content (legacy)\r\n])\r\n\r\n/**\r\n * Get the plain-text value of a node.\r\n *\r\n * ###### Algorithm\r\n *\r\n * *   if `tree` is a comment, returns its `value`\r\n * *   if `tree` is a text, applies normal whitespace collapsing to its\r\n *     `value`, as defined by the CSS Text spec\r\n * *   if `tree` is a root or element, applies an algorithm similar to the\r\n *     `innerText` getter as defined by HTML\r\n *\r\n * ###### Notes\r\n *\r\n * > 👉 **Note**: the algorithm acts as if `tree` is being rendered, and as if\r\n * > we’re a CSS-supporting user agent, with scripting enabled.\r\n *\r\n * *   if `tree` is an element that is not displayed (such as a `head`), we’ll\r\n *     still use the `innerText` algorithm instead of switching to `textContent`\r\n * *   if descendants of `tree` are elements that are not displayed, they are\r\n *     ignored\r\n * *   CSS is not considered, except for the default user agent style sheet\r\n * *   a line feed is collapsed instead of ignored in cases where Fullwidth, Wide,\r\n *     or Halfwidth East Asian Width characters are used, the same goes for a case\r\n *     with Chinese, Japanese, or Yi writing systems\r\n * *   replaced elements (such as `audio`) are treated like non-replaced elements\r\n *\r\n * @param {Nodes} tree\r\n *   Tree to turn into text.\r\n * @param {Readonly<Options> | null | undefined} [options]\r\n *   Configuration (optional).\r\n * @returns {string}\r\n *   Serialized `tree`.\r\n */\r\nexport function toText(tree, options) {\r\n  const options_ = options || {}\r\n  const children = 'children' in tree ? tree.children : []\r\n  const block = blockOrCaption(tree)\r\n  const whitespace = inferWhitespace(tree, {\r\n    whitespace: options_.whitespace || 'normal',\r\n    breakBefore: false,\r\n    breakAfter: false\r\n  })\r\n\r\n  /** @type {Array<BreakNumber | string>} */\r\n  const results = []\r\n\r\n  // Treat `text` and `comment` as having normal white-space.\r\n  // This deviates from the spec as in the DOM the node’s `.data` has to be\r\n  // returned.\r\n  // If you want that behavior use `hast-util-to-string`.\r\n  // All other nodes are later handled as if they are `element`s (so the\r\n  // algorithm also works on a `root`).\r\n  // Nodes without children are treated as a void element, so `doctype` is thus\r\n  // ignored.\r\n  if (tree.type === 'text' || tree.type === 'comment') {\r\n    results.push(\r\n      ...collectText(tree, {\r\n        whitespace,\r\n        breakBefore: true,\r\n        breakAfter: true\r\n      })\r\n    )\r\n  }\r\n\r\n  // 1.  If this element is not being rendered, or if the user agent is a\r\n  //     non-CSS user agent, then return the same value as the textContent IDL\r\n  //     attribute on this element.\r\n  //\r\n  //     Note: we’re not supporting stylesheets so we’re acting as if the node\r\n  //     is rendered.\r\n  //\r\n  //     If you want that behavior use `hast-util-to-string`.\r\n  //     Important: we’ll have to account for this later though.\r\n\r\n  // 2.  Let results be a new empty list.\r\n  let index = -1\r\n\r\n  // 3.  For each child node node of this element:\r\n  while (++index < children.length) {\r\n    // 3.1. Let current be the list resulting in running the inner text\r\n    //      collection steps with node.\r\n    //      Each item in results will either be a JavaScript string or a\r\n    //      positive integer (a required line break count).\r\n    // 3.2. For each item item in current, append item to results.\r\n    results.push(\r\n      ...renderedTextCollection(\r\n        children[index],\r\n        // @ts-expect-error: `tree` is a parent if we’re here.\r\n        tree,\r\n        {\r\n          whitespace,\r\n          breakBefore: index ? undefined : block,\r\n          breakAfter:\r\n            index < children.length - 1 ? br(children[index + 1]) : block\r\n        }\r\n      )\r\n    )\r\n  }\r\n\r\n  // 4.  Remove any items from results that are the empty string.\r\n  // 5.  Remove any runs of consecutive required line break count items at the\r\n  //     start or end of results.\r\n  // 6.  Replace each remaining run of consecutive required line break count\r\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\r\n  //     characters as the maximum of the values in the required line break\r\n  //     count items.\r\n  /** @type {Array<string>} */\r\n  const result = []\r\n  /** @type {number | undefined} */\r\n  let count\r\n\r\n  index = -1\r\n\r\n  while (++index < results.length) {\r\n    const value = results[index]\r\n\r\n    if (typeof value === 'number') {\r\n      if (count !== undefined && value > count) count = value\r\n    } else if (value) {\r\n      if (count !== undefined && count > -1) {\r\n        result.push('\\n'.repeat(count) || ' ')\r\n      }\r\n\r\n      count = -1\r\n      result.push(value)\r\n    }\r\n  }\r\n\r\n  // 7.  Return the concatenation of the string items in results.\r\n  return result.join('')\r\n}\r\n\r\n/**\r\n * <https://html.spec.whatwg.org/multipage/dom.html#rendered-text-collection-steps>\r\n *\r\n * @param {Nodes} node\r\n * @param {Parents} parent\r\n * @param {CollectionInfo} info\r\n * @returns {Array<BreakNumber | string>}\r\n */\r\nfunction renderedTextCollection(node, parent, info) {\r\n  if (node.type === 'element') {\r\n    return collectElement(node, parent, info)\r\n  }\r\n\r\n  if (node.type === 'text') {\r\n    return info.whitespace === 'normal'\r\n      ? collectText(node, info)\r\n      : collectPreText(node)\r\n  }\r\n\r\n  return []\r\n}\r\n\r\n/**\r\n * Collect an element.\r\n *\r\n * @param {Element} node\r\n *   Element node.\r\n * @param {Parents} parent\r\n * @param {CollectionInfo} info\r\n *   Info on current collection.\r\n * @returns {Array<BreakNumber | string>}\r\n */\r\nfunction collectElement(node, parent, info) {\r\n  // First we infer the `white-space` property.\r\n  const whitespace = inferWhitespace(node, info)\r\n  const children = node.children || []\r\n  let index = -1\r\n  /** @type {Array<BreakNumber | string>} */\r\n  let items = []\r\n\r\n  // We’re ignoring point 3, and exiting without any content here, because we\r\n  // deviated from the spec in `toText` at step 3.\r\n  if (notRendered(node)) {\r\n    return items\r\n  }\r\n\r\n  /** @type {BreakNumber | undefined} */\r\n  let prefix\r\n  /** @type {BreakForce | BreakNumber | undefined} */\r\n  let suffix\r\n  // Note: we first detect if there is going to be a break before or after the\r\n  // contents, as that changes the white-space handling.\r\n\r\n  // 2.  If node’s computed value of `visibility` is not `visible`, then return\r\n  //     items.\r\n  //\r\n  //     Note: Ignored, as everything is visible by default user agent styles.\r\n\r\n  // 3.  If node is not being rendered, then return items. [...]\r\n  //\r\n  //     Note: We already did this above.\r\n\r\n  // See `collectText` for step 4.\r\n\r\n  // 5.  If node is a `<br>` element, then append a string containing a single\r\n  //     U+000A LINE FEED (LF) character to items.\r\n  if (br(node)) {\r\n    suffix = '\\n'\r\n  }\r\n\r\n  // 7.  If node’s computed value of `display` is `table-row`, and node’s CSS\r\n  //     box is not the last `table-row` box of the nearest ancestor `table`\r\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\r\n  //     character to items.\r\n  //\r\n  //     See: <https://html.spec.whatwg.org/multipage/rendering.html#tables-2>\r\n  //     Note: needs further investigation as this does not account for implicit\r\n  //     rows.\r\n  else if (\r\n    row(node) &&\r\n    // @ts-expect-error: something up with types of parents.\r\n    findAfter(parent, node, row)\r\n  ) {\r\n    suffix = '\\n'\r\n  }\r\n\r\n  // 8.  If node is a `<p>` element, then append 2 (a required line break count)\r\n  //     at the beginning and end of items.\r\n  else if (p(node)) {\r\n    prefix = 2\r\n    suffix = 2\r\n  }\r\n\r\n  // 9.  If node’s used value of `display` is block-level or `table-caption`,\r\n  //     then append 1 (a required line break count) at the beginning and end of\r\n  //     items.\r\n  else if (blockOrCaption(node)) {\r\n    prefix = 1\r\n    suffix = 1\r\n  }\r\n\r\n  // 1.  Let items be the result of running the inner text collection steps with\r\n  //     each child node of node in tree order, and then concatenating the\r\n  //     results to a single list.\r\n  while (++index < children.length) {\r\n    items = items.concat(\r\n      renderedTextCollection(children[index], node, {\r\n        whitespace,\r\n        breakBefore: index ? undefined : prefix,\r\n        breakAfter:\r\n          index < children.length - 1 ? br(children[index + 1]) : suffix\r\n      })\r\n    )\r\n  }\r\n\r\n  // 6.  If node’s computed value of `display` is `table-cell`, and node’s CSS\r\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\r\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\r\n  //     (tab) character to items.\r\n  //\r\n  //     See: <https://html.spec.whatwg.org/multipage/rendering.html#tables-2>\r\n  if (\r\n    cell(node) &&\r\n    // @ts-expect-error: something up with types of parents.\r\n    findAfter(parent, node, cell)\r\n  ) {\r\n    items.push('\\t')\r\n  }\r\n\r\n  // Add the pre- and suffix.\r\n  if (prefix) items.unshift(prefix)\r\n  if (suffix) items.push(suffix)\r\n\r\n  return items\r\n}\r\n\r\n/**\r\n * 4.  If node is a Text node, then for each CSS text box produced by node,\r\n *     in content order, compute the text of the box after application of the\r\n *     CSS `white-space` processing rules and `text-transform` rules, set\r\n *     items to the list of the resulting strings, and return items.\r\n *     The CSS `white-space` processing rules are slightly modified:\r\n *     collapsible spaces at the end of lines are always collapsed, but they\r\n *     are only removed if the line is the last line of the block, or it ends\r\n *     with a br element.\r\n *     Soft hyphens should be preserved.\r\n *\r\n *     Note: See `collectText` and `collectPreText`.\r\n *     Note: we don’t deal with `text-transform`, no element has that by\r\n *     default.\r\n *\r\n * See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\r\n *\r\n * @param {Comment | Text} node\r\n *   Text node.\r\n * @param {CollectionInfo} info\r\n *   Info on current collection.\r\n * @returns {Array<BreakNumber | string>}\r\n *   Result.\r\n */\r\nfunction collectText(node, info) {\r\n  const value = String(node.value)\r\n  /** @type {Array<string>} */\r\n  const lines = []\r\n  /** @type {Array<BreakNumber | string>} */\r\n  const result = []\r\n  let start = 0\r\n\r\n  while (start <= value.length) {\r\n    searchLineFeeds.lastIndex = start\r\n\r\n    const match = searchLineFeeds.exec(value)\r\n    const end = match && 'index' in match ? match.index : value.length\r\n\r\n    lines.push(\r\n      // Any sequence of collapsible spaces and tabs immediately preceding or\r\n      // following a segment break is removed.\r\n      trimAndCollapseSpacesAndTabs(\r\n        // […] ignoring bidi formatting characters (characters with the\r\n        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\r\n        // they were not there.\r\n        value\r\n          .slice(start, end)\r\n          .replace(/[\\u061C\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]/g, ''),\r\n        start === 0 ? info.breakBefore : true,\r\n        end === value.length ? info.breakAfter : true\r\n      )\r\n    )\r\n\r\n    start = end + 1\r\n  }\r\n\r\n  // Collapsible segment breaks are transformed for rendering according to the\r\n  // segment break transformation rules.\r\n  // So here we jump to 4.1.2 of [CSSTEXT]:\r\n  // Any collapsible segment break immediately following another collapsible\r\n  // segment break is removed\r\n  let index = -1\r\n  /** @type {BreakNumber | undefined} */\r\n  let join\r\n\r\n  while (++index < lines.length) {\r\n    // *   If the character immediately before or immediately after the segment\r\n    //     break is the zero-width space character (U+200B), then the break is\r\n    //     removed, leaving behind the zero-width space.\r\n    if (\r\n      lines[index].charCodeAt(lines[index].length - 1) === 0x20_0b /* ZWSP */ ||\r\n      (index < lines.length - 1 &&\r\n        lines[index + 1].charCodeAt(0) === 0x20_0b) /* ZWSP */\r\n    ) {\r\n      result.push(lines[index])\r\n      join = undefined\r\n    }\r\n\r\n    // *   Otherwise, if the East Asian Width property [UAX11] of both the\r\n    //     character before and after the segment break is Fullwidth, Wide, or\r\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\r\n    //     segment break is removed.\r\n    //\r\n    //     Note: ignored.\r\n    // *   Otherwise, if the writing system of the segment break is Chinese,\r\n    //     Japanese, or Yi, and the character before or after the segment break\r\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\r\n    //     has an East Asian Width property of Ambiguous, and the character on\r\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\r\n    //     and not Hangul, then the segment break is removed.\r\n    //\r\n    //     Note: ignored.\r\n\r\n    // *   Otherwise, the segment break is converted to a space (U+0020).\r\n    else if (lines[index]) {\r\n      if (typeof join === 'number') result.push(join)\r\n      result.push(lines[index])\r\n      join = 0\r\n    } else if (index === 0 || index === lines.length - 1) {\r\n      // If this line is empty, and it’s the first or last, add a space.\r\n      // Note that this function is only called in normal whitespace, so we\r\n      // don’t worry about `pre`.\r\n      result.push(0)\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * Collect a text node as “pre” whitespace.\r\n *\r\n * @param {Text} node\r\n *   Text node.\r\n * @returns {Array<BreakNumber | string>}\r\n *   Result.\r\n */\r\nfunction collectPreText(node) {\r\n  return [String(node.value)]\r\n}\r\n\r\n/**\r\n * 3.  Every collapsible tab is converted to a collapsible space (U+0020).\r\n * 4.  Any collapsible space immediately following another collapsible\r\n *     space—even one outside the boundary of the inline containing that\r\n *     space, provided both spaces are within the same inline formatting\r\n *     context—is collapsed to have zero advance width. (It is invisible,\r\n *     but retains its soft wrap opportunity, if any.)\r\n *\r\n * @param {string} value\r\n *   Value to collapse.\r\n * @param {BreakBefore} breakBefore\r\n *   Whether there was a break before.\r\n * @param {BreakAfter} breakAfter\r\n *   Whether there was a break after.\r\n * @returns {string}\r\n *   Result.\r\n */\r\nfunction trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {\r\n  /** @type {Array<string>} */\r\n  const result = []\r\n  let start = 0\r\n  /** @type {number | undefined} */\r\n  let end\r\n\r\n  while (start < value.length) {\r\n    searchTabOrSpaces.lastIndex = start\r\n    const match = searchTabOrSpaces.exec(value)\r\n    end = match ? match.index : value.length\r\n\r\n    // If we’re not directly after a segment break, but there was white space,\r\n    // add an empty value that will be turned into a space.\r\n    if (!start && !end && match && !breakBefore) {\r\n      result.push('')\r\n    }\r\n\r\n    if (start !== end) {\r\n      result.push(value.slice(start, end))\r\n    }\r\n\r\n    start = match ? end + match[0].length : end\r\n  }\r\n\r\n  // If we reached the end, there was trailing white space, and there’s no\r\n  // segment break after this node, add an empty value that will be turned\r\n  // into a space.\r\n  if (start !== end && !breakAfter) {\r\n    result.push('')\r\n  }\r\n\r\n  return result.join(' ')\r\n}\r\n\r\n/**\r\n * Figure out the whitespace of a node.\r\n *\r\n * We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\r\n *\r\n * @param {Nodes} node\r\n *   Node (typically `Element`).\r\n * @param {CollectionInfo} info\r\n *   Info on current collection.\r\n * @returns {Whitespace}\r\n *   Applied whitespace.\r\n */\r\nfunction inferWhitespace(node, info) {\r\n  if (node.type === 'element') {\r\n    const properties = node.properties || {}\r\n    switch (node.tagName) {\r\n      case 'listing':\r\n      case 'plaintext':\r\n      case 'xmp': {\r\n        return 'pre'\r\n      }\r\n\r\n      case 'nobr': {\r\n        return 'nowrap'\r\n      }\r\n\r\n      case 'pre': {\r\n        return properties.wrap ? 'pre-wrap' : 'pre'\r\n      }\r\n\r\n      case 'td':\r\n      case 'th': {\r\n        return properties.noWrap ? 'nowrap' : info.whitespace\r\n      }\r\n\r\n      case 'textarea': {\r\n        return 'pre-wrap'\r\n      }\r\n\r\n      default:\r\n    }\r\n  }\r\n\r\n  return info.whitespace\r\n}\r\n\r\n/**\r\n * @type {TestFunction}\r\n * @param {Element} node\r\n * @returns {node is {properties: {hidden: true}}}\r\n */\r\nfunction hidden(node) {\r\n  return Boolean((node.properties || {}).hidden)\r\n}\r\n\r\n/**\r\n * @type {TestFunction}\r\n * @param {Element} node\r\n * @returns {node is {tagName: 'td' | 'th'}}\r\n */\r\nfunction isCell(node) {\r\n  return node.tagName === 'td' || node.tagName === 'th'\r\n}\r\n\r\n/**\r\n * @type {TestFunction}\r\n */\r\nfunction closedDialog(node) {\r\n  return node.tagName === 'dialog' && !(node.properties || {}).open\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,SAAS,QAAO,uBAAuB;AAC/C,SAAQC,cAAc,QAAO,sBAAsB;AAEnD,MAAMC,eAAe,GAAG,KAAK;AAC7B,MAAMC,iBAAiB,GAAG,SAAS;AAEnC,MAAMC,EAAE,GAAGH,cAAc,CAAC,IAAI,CAAC;AAC/B,MAAMI,IAAI,GAAGJ,cAAc,CAACK,MAAM,CAAC;AACnC,MAAMC,CAAC,GAAGN,cAAc,CAAC,GAAG,CAAC;AAC7B,MAAMO,GAAG,GAAGP,cAAc,CAAC,IAAI,CAAC;;AAEhC;AACA;AACA,MAAMQ,WAAW,GAAGR,cAAc,CAAC;AACjC;AACA,UAAU,EACV,MAAM,EACN,SAAS,EACT,UAAU,EACV,UAAU;AAAE;AACZ,IAAI,EACJ,QAAQ,EACR,OAAO,EACP,UAAU,EACV,OAAO;AACP;AACAS,MAAM;AACN;AACAC,YAAY,CACb,CAAC;;AAEF;AACA,MAAMC,cAAc,GAAGX,cAAc,CAAC,CACpC,SAAS;AAAE;AACX,SAAS;AAAE;AACX,OAAO;AAAE;AACT,YAAY;AAAE;AACd,MAAM;AAAE;AACR,SAAS;AAAE;AACX,QAAQ;AAAE;AACV,IAAI;AAAE;AACN,QAAQ;AAAE;AACV,KAAK;AAAE;AACP,IAAI;AAAE;AACN,IAAI;AAAE;AACN,KAAK;AAAE;AACP,QAAQ;AAAE;AACV,YAAY;AAAE;AACd,QAAQ;AAAE;AACV,OAAO;AAAE;AACT,IAAI;AAAE;AACN,IAAI;AAAE;AACN,IAAI;AAAE;AACN,IAAI;AAAE;AACN,IAAI;AAAE;AACN,IAAI;AAAE;AACN,QAAQ;AAAE;AACV,QAAQ;AAAE;AACV,IAAI;AAAE;AACN,MAAM;AAAE;AACR,QAAQ;AAAE;AACV,IAAI;AAAE;AACN,SAAS;AAAE;AACX,MAAM;AAAE;AACR,MAAM;AAAE;AACR,KAAK;AAAE;AACP,IAAI;AAAE;AACN,GAAG;AAAE;AACL,WAAW;AAAE;AACb,KAAK;AAAE;AACP,SAAS;AAAE;AACX,IAAI;AAAE;AACN,KAAK,CAAC;AAAA,CACP,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASY,MAAMA,CAACC,IAAI,EAAEC,OAAO,EAAE;EACpC,MAAMC,QAAQ,GAAGD,OAAO,IAAI,CAAC,CAAC;EAC9B,MAAME,QAAQ,GAAG,UAAU,IAAIH,IAAI,GAAGA,IAAI,CAACG,QAAQ,GAAG,EAAE;EACxD,MAAMC,KAAK,GAAGN,cAAc,CAACE,IAAI,CAAC;EAClC,MAAMK,UAAU,GAAGC,eAAe,CAACN,IAAI,EAAE;IACvCK,UAAU,EAAEH,QAAQ,CAACG,UAAU,IAAI,QAAQ;IAC3CE,WAAW,EAAE,KAAK;IAClBC,UAAU,EAAE;EACd,CAAC,CAAC;;EAEF;EACA,MAAMC,OAAO,GAAG,EAAE;;EAElB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAIT,IAAI,CAACU,IAAI,KAAK,MAAM,IAAIV,IAAI,CAACU,IAAI,KAAK,SAAS,EAAE;IACnDD,OAAO,CAACE,IAAI,CACV,GAAGC,WAAW,CAACZ,IAAI,EAAE;MACnBK,UAAU;MACVE,WAAW,EAAE,IAAI;MACjBC,UAAU,EAAE;IACd,CAAC,CACH,CAAC;EACH;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA,IAAIK,KAAK,GAAG,CAAC,CAAC;;EAEd;EACA,OAAO,EAAEA,KAAK,GAAGV,QAAQ,CAACW,MAAM,EAAE;IAChC;IACA;IACA;IACA;IACA;IACAL,OAAO,CAACE,IAAI,CACV,GAAGI,sBAAsB,CACvBZ,QAAQ,CAACU,KAAK,CAAC;IACf;IACAb,IAAI,EACJ;MACEK,UAAU;MACVE,WAAW,EAAEM,KAAK,GAAGG,SAAS,GAAGZ,KAAK;MACtCI,UAAU,EACRK,KAAK,GAAGV,QAAQ,CAACW,MAAM,GAAG,CAAC,GAAGxB,EAAE,CAACa,QAAQ,CAACU,KAAK,GAAG,CAAC,CAAC,CAAC,GAAGT;IAC5D,CACF,CACF,CAAC;EACH;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,MAAMa,MAAM,GAAG,EAAE;EACjB;EACA,IAAIC,KAAK;EAETL,KAAK,GAAG,CAAC,CAAC;EAEV,OAAO,EAAEA,KAAK,GAAGJ,OAAO,CAACK,MAAM,EAAE;IAC/B,MAAMK,KAAK,GAAGV,OAAO,CAACI,KAAK,CAAC;IAE5B,IAAI,OAAOM,KAAK,KAAK,QAAQ,EAAE;MAC7B,IAAID,KAAK,KAAKF,SAAS,IAAIG,KAAK,GAAGD,KAAK,EAAEA,KAAK,GAAGC,KAAK;IACzD,CAAC,MAAM,IAAIA,KAAK,EAAE;MAChB,IAAID,KAAK,KAAKF,SAAS,IAAIE,KAAK,GAAG,CAAC,CAAC,EAAE;QACrCD,MAAM,CAACN,IAAI,CAAC,IAAI,CAACS,MAAM,CAACF,KAAK,CAAC,IAAI,GAAG,CAAC;MACxC;MAEAA,KAAK,GAAG,CAAC,CAAC;MACVD,MAAM,CAACN,IAAI,CAACQ,KAAK,CAAC;IACpB;EACF;;EAEA;EACA,OAAOF,MAAM,CAACI,IAAI,CAAC,EAAE,CAAC;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASN,sBAAsBA,CAACO,IAAI,EAAEC,MAAM,EAAEC,IAAI,EAAE;EAClD,IAAIF,IAAI,CAACZ,IAAI,KAAK,SAAS,EAAE;IAC3B,OAAOe,cAAc,CAACH,IAAI,EAAEC,MAAM,EAAEC,IAAI,CAAC;EAC3C;EAEA,IAAIF,IAAI,CAACZ,IAAI,KAAK,MAAM,EAAE;IACxB,OAAOc,IAAI,CAACnB,UAAU,KAAK,QAAQ,GAC/BO,WAAW,CAACU,IAAI,EAAEE,IAAI,CAAC,GACvBE,cAAc,CAACJ,IAAI,CAAC;EAC1B;EAEA,OAAO,EAAE;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,cAAcA,CAACH,IAAI,EAAEC,MAAM,EAAEC,IAAI,EAAE;EAC1C;EACA,MAAMnB,UAAU,GAAGC,eAAe,CAACgB,IAAI,EAAEE,IAAI,CAAC;EAC9C,MAAMrB,QAAQ,GAAGmB,IAAI,CAACnB,QAAQ,IAAI,EAAE;EACpC,IAAIU,KAAK,GAAG,CAAC,CAAC;EACd;EACA,IAAIc,KAAK,GAAG,EAAE;;EAEd;EACA;EACA,IAAIhC,WAAW,CAAC2B,IAAI,CAAC,EAAE;IACrB,OAAOK,KAAK;EACd;;EAEA;EACA,IAAIC,MAAM;EACV;EACA,IAAIC,MAAM;EACV;EACA;;EAEA;EACA;EACA;EACA;;EAEA;EACA;EACA;;EAEA;;EAEA;EACA;EACA,IAAIvC,EAAE,CAACgC,IAAI,CAAC,EAAE;IACZO,MAAM,GAAG,IAAI;EACf;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAAA,KACK,IACHnC,GAAG,CAAC4B,IAAI,CAAC;EACT;EACApC,SAAS,CAACqC,MAAM,EAAED,IAAI,EAAE5B,GAAG,CAAC,EAC5B;IACAmC,MAAM,GAAG,IAAI;EACf;;EAEA;EACA;EAAA,KACK,IAAIpC,CAAC,CAAC6B,IAAI,CAAC,EAAE;IAChBM,MAAM,GAAG,CAAC;IACVC,MAAM,GAAG,CAAC;EACZ;;EAEA;EACA;EACA;EAAA,KACK,IAAI/B,cAAc,CAACwB,IAAI,CAAC,EAAE;IAC7BM,MAAM,GAAG,CAAC;IACVC,MAAM,GAAG,CAAC;EACZ;;EAEA;EACA;EACA;EACA,OAAO,EAAEhB,KAAK,GAAGV,QAAQ,CAACW,MAAM,EAAE;IAChCa,KAAK,GAAGA,KAAK,CAACG,MAAM,CAClBf,sBAAsB,CAACZ,QAAQ,CAACU,KAAK,CAAC,EAAES,IAAI,EAAE;MAC5CjB,UAAU;MACVE,WAAW,EAAEM,KAAK,GAAGG,SAAS,GAAGY,MAAM;MACvCpB,UAAU,EACRK,KAAK,GAAGV,QAAQ,CAACW,MAAM,GAAG,CAAC,GAAGxB,EAAE,CAACa,QAAQ,CAACU,KAAK,GAAG,CAAC,CAAC,CAAC,GAAGgB;IAC5D,CAAC,CACH,CAAC;EACH;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA,IACEtC,IAAI,CAAC+B,IAAI,CAAC;EACV;EACApC,SAAS,CAACqC,MAAM,EAAED,IAAI,EAAE/B,IAAI,CAAC,EAC7B;IACAoC,KAAK,CAAChB,IAAI,CAAC,IAAI,CAAC;EAClB;;EAEA;EACA,IAAIiB,MAAM,EAAED,KAAK,CAACI,OAAO,CAACH,MAAM,CAAC;EACjC,IAAIC,MAAM,EAAEF,KAAK,CAAChB,IAAI,CAACkB,MAAM,CAAC;EAE9B,OAAOF,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASf,WAAWA,CAACU,IAAI,EAAEE,IAAI,EAAE;EAC/B,MAAML,KAAK,GAAGa,MAAM,CAACV,IAAI,CAACH,KAAK,CAAC;EAChC;EACA,MAAMc,KAAK,GAAG,EAAE;EAChB;EACA,MAAMhB,MAAM,GAAG,EAAE;EACjB,IAAIiB,KAAK,GAAG,CAAC;EAEb,OAAOA,KAAK,IAAIf,KAAK,CAACL,MAAM,EAAE;IAC5B1B,eAAe,CAAC+C,SAAS,GAAGD,KAAK;IAEjC,MAAME,KAAK,GAAGhD,eAAe,CAACiD,IAAI,CAAClB,KAAK,CAAC;IACzC,MAAMmB,GAAG,GAAGF,KAAK,IAAI,OAAO,IAAIA,KAAK,GAAGA,KAAK,CAACvB,KAAK,GAAGM,KAAK,CAACL,MAAM;IAElEmB,KAAK,CAACtB,IAAI;IACR;IACA;IACA4B,4BAA4B;IAC1B;IACA;IACA;IACApB,KAAK,CACFqB,KAAK,CAACN,KAAK,EAAEI,GAAG,CAAC,CACjBG,OAAO,CAAC,iDAAiD,EAAE,EAAE,CAAC,EACjEP,KAAK,KAAK,CAAC,GAAGV,IAAI,CAACjB,WAAW,GAAG,IAAI,EACrC+B,GAAG,KAAKnB,KAAK,CAACL,MAAM,GAAGU,IAAI,CAAChB,UAAU,GAAG,IAC3C,CACF,CAAC;IAED0B,KAAK,GAAGI,GAAG,GAAG,CAAC;EACjB;;EAEA;EACA;EACA;EACA;EACA;EACA,IAAIzB,KAAK,GAAG,CAAC,CAAC;EACd;EACA,IAAIQ,IAAI;EAER,OAAO,EAAER,KAAK,GAAGoB,KAAK,CAACnB,MAAM,EAAE;IAC7B;IACA;IACA;IACA,IACEmB,KAAK,CAACpB,KAAK,CAAC,CAAC6B,UAAU,CAACT,KAAK,CAACpB,KAAK,CAAC,CAACC,MAAM,GAAG,CAAC,CAAC,KAAK,OAAO,CAAC,cAC5DD,KAAK,GAAGoB,KAAK,CAACnB,MAAM,GAAG,CAAC,IACvBmB,KAAK,CAACpB,KAAK,GAAG,CAAC,CAAC,CAAC6B,UAAU,CAAC,CAAC,CAAC,KAAK,OAAQ,CAAC,YAC9C;MACAzB,MAAM,CAACN,IAAI,CAACsB,KAAK,CAACpB,KAAK,CAAC,CAAC;MACzBQ,IAAI,GAAGL,SAAS;IAClB;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IAAA,KACK,IAAIiB,KAAK,CAACpB,KAAK,CAAC,EAAE;MACrB,IAAI,OAAOQ,IAAI,KAAK,QAAQ,EAAEJ,MAAM,CAACN,IAAI,CAACU,IAAI,CAAC;MAC/CJ,MAAM,CAACN,IAAI,CAACsB,KAAK,CAACpB,KAAK,CAAC,CAAC;MACzBQ,IAAI,GAAG,CAAC;IACV,CAAC,MAAM,IAAIR,KAAK,KAAK,CAAC,IAAIA,KAAK,KAAKoB,KAAK,CAACnB,MAAM,GAAG,CAAC,EAAE;MACpD;MACA;MACA;MACAG,MAAM,CAACN,IAAI,CAAC,CAAC,CAAC;IAChB;EACF;EAEA,OAAOM,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASS,cAAcA,CAACJ,IAAI,EAAE;EAC5B,OAAO,CAACU,MAAM,CAACV,IAAI,CAACH,KAAK,CAAC,CAAC;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASoB,4BAA4BA,CAACpB,KAAK,EAAEZ,WAAW,EAAEC,UAAU,EAAE;EACpE;EACA,MAAMS,MAAM,GAAG,EAAE;EACjB,IAAIiB,KAAK,GAAG,CAAC;EACb;EACA,IAAII,GAAG;EAEP,OAAOJ,KAAK,GAAGf,KAAK,CAACL,MAAM,EAAE;IAC3BzB,iBAAiB,CAAC8C,SAAS,GAAGD,KAAK;IACnC,MAAME,KAAK,GAAG/C,iBAAiB,CAACgD,IAAI,CAAClB,KAAK,CAAC;IAC3CmB,GAAG,GAAGF,KAAK,GAAGA,KAAK,CAACvB,KAAK,GAAGM,KAAK,CAACL,MAAM;;IAExC;IACA;IACA,IAAI,CAACoB,KAAK,IAAI,CAACI,GAAG,IAAIF,KAAK,IAAI,CAAC7B,WAAW,EAAE;MAC3CU,MAAM,CAACN,IAAI,CAAC,EAAE,CAAC;IACjB;IAEA,IAAIuB,KAAK,KAAKI,GAAG,EAAE;MACjBrB,MAAM,CAACN,IAAI,CAACQ,KAAK,CAACqB,KAAK,CAACN,KAAK,EAAEI,GAAG,CAAC,CAAC;IACtC;IAEAJ,KAAK,GAAGE,KAAK,GAAGE,GAAG,GAAGF,KAAK,CAAC,CAAC,CAAC,CAACtB,MAAM,GAAGwB,GAAG;EAC7C;;EAEA;EACA;EACA;EACA,IAAIJ,KAAK,KAAKI,GAAG,IAAI,CAAC9B,UAAU,EAAE;IAChCS,MAAM,CAACN,IAAI,CAAC,EAAE,CAAC;EACjB;EAEA,OAAOM,MAAM,CAACI,IAAI,CAAC,GAAG,CAAC;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASf,eAAeA,CAACgB,IAAI,EAAEE,IAAI,EAAE;EACnC,IAAIF,IAAI,CAACZ,IAAI,KAAK,SAAS,EAAE;IAC3B,MAAMiC,UAAU,GAAGrB,IAAI,CAACqB,UAAU,IAAI,CAAC,CAAC;IACxC,QAAQrB,IAAI,CAACsB,OAAO;MAClB,KAAK,SAAS;MACd,KAAK,WAAW;MAChB,KAAK,KAAK;QAAE;UACV,OAAO,KAAK;QACd;MAEA,KAAK,MAAM;QAAE;UACX,OAAO,QAAQ;QACjB;MAEA,KAAK,KAAK;QAAE;UACV,OAAOD,UAAU,CAACE,IAAI,GAAG,UAAU,GAAG,KAAK;QAC7C;MAEA,KAAK,IAAI;MACT,KAAK,IAAI;QAAE;UACT,OAAOF,UAAU,CAACG,MAAM,GAAG,QAAQ,GAAGtB,IAAI,CAACnB,UAAU;QACvD;MAEA,KAAK,UAAU;QAAE;UACf,OAAO,UAAU;QACnB;MAEA;IACF;EACF;EAEA,OAAOmB,IAAI,CAACnB,UAAU;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAST,MAAMA,CAAC0B,IAAI,EAAE;EACpB,OAAOyB,OAAO,CAAC,CAACzB,IAAI,CAACqB,UAAU,IAAI,CAAC,CAAC,EAAE/C,MAAM,CAAC;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASJ,MAAMA,CAAC8B,IAAI,EAAE;EACpB,OAAOA,IAAI,CAACsB,OAAO,KAAK,IAAI,IAAItB,IAAI,CAACsB,OAAO,KAAK,IAAI;AACvD;;AAEA;AACA;AACA;AACA,SAAS/C,YAAYA,CAACyB,IAAI,EAAE;EAC1B,OAAOA,IAAI,CAACsB,OAAO,KAAK,QAAQ,IAAI,CAAC,CAACtB,IAAI,CAACqB,UAAU,IAAI,CAAC,CAAC,EAAEK,IAAI;AACnE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}