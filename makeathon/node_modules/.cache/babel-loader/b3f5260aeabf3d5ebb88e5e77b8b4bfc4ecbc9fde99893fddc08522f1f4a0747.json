{"ast":null,"code":"/**\r\n * @import {Element, Nodes, RootContent, Root} from 'hast'\r\n * @import {Info, Schema} from 'property-information'\r\n */\n\n/**\r\n * @typedef {Array<Nodes | PrimitiveChild>} ArrayChildNested\r\n *   List of children (deep).\r\n */\n\n/**\r\n * @typedef {Array<ArrayChildNested | Nodes | PrimitiveChild>} ArrayChild\r\n *   List of children.\r\n */\n\n/**\r\n * @typedef {Array<number | string>} ArrayValue\r\n *   List of property values for space- or comma separated values (such as `className`).\r\n */\n\n/**\r\n * @typedef {ArrayChild | Nodes | PrimitiveChild} Child\r\n *   Acceptable child value.\r\n */\n\n/**\r\n * @typedef {number | string | null | undefined} PrimitiveChild\r\n *   Primitive children, either ignored (nullish), or turned into text nodes.\r\n */\n\n/**\r\n * @typedef {boolean | number | string | null | undefined} PrimitiveValue\r\n *   Primitive property value.\r\n */\n\n/**\r\n * @typedef {Record<string, PropertyValue | Style>} Properties\r\n *   Acceptable value for element properties.\r\n */\n\n/**\r\n * @typedef {ArrayValue | PrimitiveValue} PropertyValue\r\n *   Primitive value or list value.\r\n */\n\n/**\r\n * @typedef {Element | Root} Result\r\n *   Result from a `h` (or `s`) call.\r\n */\n\n/**\r\n * @typedef {number | string} StyleValue\r\n *   Value for a CSS style field.\r\n */\n\n/**\r\n * @typedef {Record<string, StyleValue>} Style\r\n *   Supported value of a `style` prop.\r\n */\n\nimport { parse as parseCommas } from 'comma-separated-tokens';\nimport { parseSelector } from 'hast-util-parse-selector';\nimport { find, normalize } from 'property-information';\nimport { parse as parseSpaces } from 'space-separated-tokens';\n\n/**\r\n * @param {Schema} schema\r\n *   Schema to use.\r\n * @param {string} defaultTagName\r\n *   Default tag name.\r\n * @param {ReadonlyArray<string> | undefined} [caseSensitive]\r\n *   Case-sensitive tag names (default: `undefined`).\r\n * @returns\r\n *   `h`.\r\n */\nexport function createH(schema, defaultTagName, caseSensitive) {\n  const adjust = caseSensitive ? createAdjustMap(caseSensitive) : undefined;\n\n  /**\r\n   * Hyperscript compatible DSL for creating virtual hast trees.\r\n   *\r\n   * @overload\r\n   * @param {null | undefined} [selector]\r\n   * @param {...Child} children\r\n   * @returns {Root}\r\n   *\r\n   * @overload\r\n   * @param {string} selector\r\n   * @param {Properties} properties\r\n   * @param {...Child} children\r\n   * @returns {Element}\r\n   *\r\n   * @overload\r\n   * @param {string} selector\r\n   * @param {...Child} children\r\n   * @returns {Element}\r\n   *\r\n   * @param {string | null | undefined} [selector]\r\n   *   Selector.\r\n   * @param {Child | Properties | null | undefined} [properties]\r\n   *   Properties (or first child) (default: `undefined`).\r\n   * @param {...Child} children\r\n   *   Children.\r\n   * @returns {Result}\r\n   *   Result.\r\n   */\n  function h(selector, properties, ...children) {\n    /** @type {Result} */\n    let node;\n    if (selector === null || selector === undefined) {\n      node = {\n        type: 'root',\n        children: []\n      };\n      // Properties are not supported for roots.\n      const child = /** @type {Child} */properties;\n      children.unshift(child);\n    } else {\n      node = parseSelector(selector, defaultTagName);\n      // Normalize the name.\n      const lower = node.tagName.toLowerCase();\n      const adjusted = adjust ? adjust.get(lower) : undefined;\n      node.tagName = adjusted || lower;\n\n      // Handle properties.\n      if (isChild(properties)) {\n        children.unshift(properties);\n      } else {\n        for (const [key, value] of Object.entries(properties)) {\n          addProperty(schema, node.properties, key, value);\n        }\n      }\n    }\n\n    // Handle children.\n    for (const child of children) {\n      addChild(node.children, child);\n    }\n    if (node.type === 'element' && node.tagName === 'template') {\n      node.content = {\n        type: 'root',\n        children: node.children\n      };\n      node.children = [];\n    }\n    return node;\n  }\n  return h;\n}\n\n/**\r\n * Check if something is properties or a child.\r\n *\r\n * @param {Child | Properties} value\r\n *   Value to check.\r\n * @returns {value is Child}\r\n *   Whether `value` is definitely a child.\r\n */\nfunction isChild(value) {\n  // Never properties if not an object.\n  if (value === null || typeof value !== 'object' || Array.isArray(value)) {\n    return true;\n  }\n\n  // Never node without `type`; thatâ€™s the main discriminator.\n  if (typeof value.type !== 'string') return false;\n\n  // Slower check: never property value if object or array with\n  // non-number/strings.\n  const record = /** @type {Record<string, unknown>} */value;\n  const keys = Object.keys(value);\n  for (const key of keys) {\n    const value = record[key];\n    if (value && typeof value === 'object') {\n      if (!Array.isArray(value)) return true;\n      const list = /** @type {ReadonlyArray<unknown>} */value;\n      for (const item of list) {\n        if (typeof item !== 'number' && typeof item !== 'string') {\n          return true;\n        }\n      }\n    }\n  }\n\n  // Also see empty `children` as a node.\n  if ('children' in value && Array.isArray(value.children)) {\n    return true;\n  }\n\n  // Default to properties, someone can always pass an empty object,\n  // put `data: {}` in a node,\n  // or wrap it in an array.\n  return false;\n}\n\n/**\r\n * @param {Schema} schema\r\n *   Schema.\r\n * @param {Properties} properties\r\n *   Properties object.\r\n * @param {string} key\r\n *   Property name.\r\n * @param {PropertyValue | Style} value\r\n *   Property value.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\nfunction addProperty(schema, properties, key, value) {\n  const info = find(schema, key);\n  /** @type {PropertyValue} */\n  let result;\n\n  // Ignore nullish and NaN values.\n  if (value === null || value === undefined) return;\n  if (typeof value === 'number') {\n    // Ignore NaN.\n    if (Number.isNaN(value)) return;\n    result = value;\n  }\n  // Booleans.\n  else if (typeof value === 'boolean') {\n    result = value;\n  }\n  // Handle list values.\n  else if (typeof value === 'string') {\n    if (info.spaceSeparated) {\n      result = parseSpaces(value);\n    } else if (info.commaSeparated) {\n      result = parseCommas(value);\n    } else if (info.commaOrSpaceSeparated) {\n      result = parseSpaces(parseCommas(value).join(' '));\n    } else {\n      result = parsePrimitive(info, info.property, value);\n    }\n  } else if (Array.isArray(value)) {\n    result = [...value];\n  } else {\n    result = info.property === 'style' ? style(value) : String(value);\n  }\n  if (Array.isArray(result)) {\n    /** @type {Array<number | string>} */\n    const finalResult = [];\n    for (const item of result) {\n      // Assume no booleans in array.\n      finalResult.push(/** @type {number | string} */\n      parsePrimitive(info, info.property, item));\n    }\n    result = finalResult;\n  }\n\n  // Class names (which can be added both on the `selector` and here).\n  if (info.property === 'className' && Array.isArray(properties.className)) {\n    // Assume no booleans in `className`.\n    result = properties.className.concat(/** @type {Array<number | string> | number | string} */result);\n  }\n  properties[info.property] = result;\n}\n\n/**\r\n * @param {Array<RootContent>} nodes\r\n *   Children.\r\n * @param {Child} value\r\n *   Child.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\nfunction addChild(nodes, value) {\n  if (value === null || value === undefined) {\n    // Empty.\n  } else if (typeof value === 'number' || typeof value === 'string') {\n    nodes.push({\n      type: 'text',\n      value: String(value)\n    });\n  } else if (Array.isArray(value)) {\n    for (const child of value) {\n      addChild(nodes, child);\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children);\n    } else {\n      nodes.push(value);\n    }\n  } else {\n    throw new Error('Expected node, nodes, or string, got `' + value + '`');\n  }\n}\n\n/**\r\n * Parse a single primitives.\r\n *\r\n * @param {Info} info\r\n *   Property information.\r\n * @param {string} name\r\n *   Property name.\r\n * @param {PrimitiveValue} value\r\n *   Property value.\r\n * @returns {PrimitiveValue}\r\n *   Property value.\r\n */\nfunction parsePrimitive(info, name, value) {\n  if (typeof value === 'string') {\n    if (info.number && value && !Number.isNaN(Number(value))) {\n      return Number(value);\n    }\n    if ((info.boolean || info.overloadedBoolean) && (value === '' || normalize(value) === normalize(name))) {\n      return true;\n    }\n  }\n  return value;\n}\n\n/**\r\n * Serialize a `style` object as a string.\r\n *\r\n * @param {Style} styles\r\n *   Style object.\r\n * @returns {string}\r\n *   CSS string.\r\n */\nfunction style(styles) {\n  /** @type {Array<string>} */\n  const result = [];\n  for (const [key, value] of Object.entries(styles)) {\n    result.push([key, value].join(': '));\n  }\n  return result.join('; ');\n}\n\n/**\r\n * Create a map to adjust casing.\r\n *\r\n * @param {ReadonlyArray<string>} values\r\n *   List of properly cased keys.\r\n * @returns {Map<string, string>}\r\n *   Map of lowercase keys to uppercase keys.\r\n */\nfunction createAdjustMap(values) {\n  /** @type {Map<string, string>} */\n  const result = new Map();\n  for (const value of values) {\n    result.set(value.toLowerCase(), value);\n  }\n  return result;\n}","map":{"version":3,"names":["parse","parseCommas","parseSelector","find","normalize","parseSpaces","createH","schema","defaultTagName","caseSensitive","adjust","createAdjustMap","undefined","h","selector","properties","children","node","type","child","unshift","lower","tagName","toLowerCase","adjusted","get","isChild","key","value","Object","entries","addProperty","addChild","content","Array","isArray","record","keys","list","item","info","result","Number","isNaN","spaceSeparated","commaSeparated","commaOrSpaceSeparated","join","parsePrimitive","property","style","String","finalResult","push","className","concat","nodes","Error","name","number","boolean","overloadedBoolean","styles","values","Map","set"],"sources":["C:/Users/smart/Downloads/Final Project P20119/makeathon-2025/makeathon/node_modules/hastscript/lib/create-h.js"],"sourcesContent":["/**\r\n * @import {Element, Nodes, RootContent, Root} from 'hast'\r\n * @import {Info, Schema} from 'property-information'\r\n */\r\n\r\n/**\r\n * @typedef {Array<Nodes | PrimitiveChild>} ArrayChildNested\r\n *   List of children (deep).\r\n */\r\n\r\n/**\r\n * @typedef {Array<ArrayChildNested | Nodes | PrimitiveChild>} ArrayChild\r\n *   List of children.\r\n */\r\n\r\n/**\r\n * @typedef {Array<number | string>} ArrayValue\r\n *   List of property values for space- or comma separated values (such as `className`).\r\n */\r\n\r\n/**\r\n * @typedef {ArrayChild | Nodes | PrimitiveChild} Child\r\n *   Acceptable child value.\r\n */\r\n\r\n/**\r\n * @typedef {number | string | null | undefined} PrimitiveChild\r\n *   Primitive children, either ignored (nullish), or turned into text nodes.\r\n */\r\n\r\n/**\r\n * @typedef {boolean | number | string | null | undefined} PrimitiveValue\r\n *   Primitive property value.\r\n */\r\n\r\n/**\r\n * @typedef {Record<string, PropertyValue | Style>} Properties\r\n *   Acceptable value for element properties.\r\n */\r\n\r\n/**\r\n * @typedef {ArrayValue | PrimitiveValue} PropertyValue\r\n *   Primitive value or list value.\r\n */\r\n\r\n/**\r\n * @typedef {Element | Root} Result\r\n *   Result from a `h` (or `s`) call.\r\n */\r\n\r\n/**\r\n * @typedef {number | string} StyleValue\r\n *   Value for a CSS style field.\r\n */\r\n\r\n/**\r\n * @typedef {Record<string, StyleValue>} Style\r\n *   Supported value of a `style` prop.\r\n */\r\n\r\nimport {parse as parseCommas} from 'comma-separated-tokens'\r\nimport {parseSelector} from 'hast-util-parse-selector'\r\nimport {find, normalize} from 'property-information'\r\nimport {parse as parseSpaces} from 'space-separated-tokens'\r\n\r\n/**\r\n * @param {Schema} schema\r\n *   Schema to use.\r\n * @param {string} defaultTagName\r\n *   Default tag name.\r\n * @param {ReadonlyArray<string> | undefined} [caseSensitive]\r\n *   Case-sensitive tag names (default: `undefined`).\r\n * @returns\r\n *   `h`.\r\n */\r\nexport function createH(schema, defaultTagName, caseSensitive) {\r\n  const adjust = caseSensitive ? createAdjustMap(caseSensitive) : undefined\r\n\r\n  /**\r\n   * Hyperscript compatible DSL for creating virtual hast trees.\r\n   *\r\n   * @overload\r\n   * @param {null | undefined} [selector]\r\n   * @param {...Child} children\r\n   * @returns {Root}\r\n   *\r\n   * @overload\r\n   * @param {string} selector\r\n   * @param {Properties} properties\r\n   * @param {...Child} children\r\n   * @returns {Element}\r\n   *\r\n   * @overload\r\n   * @param {string} selector\r\n   * @param {...Child} children\r\n   * @returns {Element}\r\n   *\r\n   * @param {string | null | undefined} [selector]\r\n   *   Selector.\r\n   * @param {Child | Properties | null | undefined} [properties]\r\n   *   Properties (or first child) (default: `undefined`).\r\n   * @param {...Child} children\r\n   *   Children.\r\n   * @returns {Result}\r\n   *   Result.\r\n   */\r\n  function h(selector, properties, ...children) {\r\n    /** @type {Result} */\r\n    let node\r\n\r\n    if (selector === null || selector === undefined) {\r\n      node = {type: 'root', children: []}\r\n      // Properties are not supported for roots.\r\n      const child = /** @type {Child} */ (properties)\r\n      children.unshift(child)\r\n    } else {\r\n      node = parseSelector(selector, defaultTagName)\r\n      // Normalize the name.\r\n      const lower = node.tagName.toLowerCase()\r\n      const adjusted = adjust ? adjust.get(lower) : undefined\r\n      node.tagName = adjusted || lower\r\n\r\n      // Handle properties.\r\n      if (isChild(properties)) {\r\n        children.unshift(properties)\r\n      } else {\r\n        for (const [key, value] of Object.entries(properties)) {\r\n          addProperty(schema, node.properties, key, value)\r\n        }\r\n      }\r\n    }\r\n\r\n    // Handle children.\r\n    for (const child of children) {\r\n      addChild(node.children, child)\r\n    }\r\n\r\n    if (node.type === 'element' && node.tagName === 'template') {\r\n      node.content = {type: 'root', children: node.children}\r\n      node.children = []\r\n    }\r\n\r\n    return node\r\n  }\r\n\r\n  return h\r\n}\r\n\r\n/**\r\n * Check if something is properties or a child.\r\n *\r\n * @param {Child | Properties} value\r\n *   Value to check.\r\n * @returns {value is Child}\r\n *   Whether `value` is definitely a child.\r\n */\r\nfunction isChild(value) {\r\n  // Never properties if not an object.\r\n  if (value === null || typeof value !== 'object' || Array.isArray(value)) {\r\n    return true\r\n  }\r\n\r\n  // Never node without `type`; thatâ€™s the main discriminator.\r\n  if (typeof value.type !== 'string') return false\r\n\r\n  // Slower check: never property value if object or array with\r\n  // non-number/strings.\r\n  const record = /** @type {Record<string, unknown>} */ (value)\r\n  const keys = Object.keys(value)\r\n\r\n  for (const key of keys) {\r\n    const value = record[key]\r\n\r\n    if (value && typeof value === 'object') {\r\n      if (!Array.isArray(value)) return true\r\n\r\n      const list = /** @type {ReadonlyArray<unknown>} */ (value)\r\n\r\n      for (const item of list) {\r\n        if (typeof item !== 'number' && typeof item !== 'string') {\r\n          return true\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Also see empty `children` as a node.\r\n  if ('children' in value && Array.isArray(value.children)) {\r\n    return true\r\n  }\r\n\r\n  // Default to properties, someone can always pass an empty object,\r\n  // put `data: {}` in a node,\r\n  // or wrap it in an array.\r\n  return false\r\n}\r\n\r\n/**\r\n * @param {Schema} schema\r\n *   Schema.\r\n * @param {Properties} properties\r\n *   Properties object.\r\n * @param {string} key\r\n *   Property name.\r\n * @param {PropertyValue | Style} value\r\n *   Property value.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nfunction addProperty(schema, properties, key, value) {\r\n  const info = find(schema, key)\r\n  /** @type {PropertyValue} */\r\n  let result\r\n\r\n  // Ignore nullish and NaN values.\r\n  if (value === null || value === undefined) return\r\n\r\n  if (typeof value === 'number') {\r\n    // Ignore NaN.\r\n    if (Number.isNaN(value)) return\r\n\r\n    result = value\r\n  }\r\n  // Booleans.\r\n  else if (typeof value === 'boolean') {\r\n    result = value\r\n  }\r\n  // Handle list values.\r\n  else if (typeof value === 'string') {\r\n    if (info.spaceSeparated) {\r\n      result = parseSpaces(value)\r\n    } else if (info.commaSeparated) {\r\n      result = parseCommas(value)\r\n    } else if (info.commaOrSpaceSeparated) {\r\n      result = parseSpaces(parseCommas(value).join(' '))\r\n    } else {\r\n      result = parsePrimitive(info, info.property, value)\r\n    }\r\n  } else if (Array.isArray(value)) {\r\n    result = [...value]\r\n  } else {\r\n    result = info.property === 'style' ? style(value) : String(value)\r\n  }\r\n\r\n  if (Array.isArray(result)) {\r\n    /** @type {Array<number | string>} */\r\n    const finalResult = []\r\n\r\n    for (const item of result) {\r\n      // Assume no booleans in array.\r\n      finalResult.push(\r\n        /** @type {number | string} */ (\r\n          parsePrimitive(info, info.property, item)\r\n        )\r\n      )\r\n    }\r\n\r\n    result = finalResult\r\n  }\r\n\r\n  // Class names (which can be added both on the `selector` and here).\r\n  if (info.property === 'className' && Array.isArray(properties.className)) {\r\n    // Assume no booleans in `className`.\r\n    result = properties.className.concat(\r\n      /** @type {Array<number | string> | number | string} */ (result)\r\n    )\r\n  }\r\n\r\n  properties[info.property] = result\r\n}\r\n\r\n/**\r\n * @param {Array<RootContent>} nodes\r\n *   Children.\r\n * @param {Child} value\r\n *   Child.\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nfunction addChild(nodes, value) {\r\n  if (value === null || value === undefined) {\r\n    // Empty.\r\n  } else if (typeof value === 'number' || typeof value === 'string') {\r\n    nodes.push({type: 'text', value: String(value)})\r\n  } else if (Array.isArray(value)) {\r\n    for (const child of value) {\r\n      addChild(nodes, child)\r\n    }\r\n  } else if (typeof value === 'object' && 'type' in value) {\r\n    if (value.type === 'root') {\r\n      addChild(nodes, value.children)\r\n    } else {\r\n      nodes.push(value)\r\n    }\r\n  } else {\r\n    throw new Error('Expected node, nodes, or string, got `' + value + '`')\r\n  }\r\n}\r\n\r\n/**\r\n * Parse a single primitives.\r\n *\r\n * @param {Info} info\r\n *   Property information.\r\n * @param {string} name\r\n *   Property name.\r\n * @param {PrimitiveValue} value\r\n *   Property value.\r\n * @returns {PrimitiveValue}\r\n *   Property value.\r\n */\r\nfunction parsePrimitive(info, name, value) {\r\n  if (typeof value === 'string') {\r\n    if (info.number && value && !Number.isNaN(Number(value))) {\r\n      return Number(value)\r\n    }\r\n\r\n    if (\r\n      (info.boolean || info.overloadedBoolean) &&\r\n      (value === '' || normalize(value) === normalize(name))\r\n    ) {\r\n      return true\r\n    }\r\n  }\r\n\r\n  return value\r\n}\r\n\r\n/**\r\n * Serialize a `style` object as a string.\r\n *\r\n * @param {Style} styles\r\n *   Style object.\r\n * @returns {string}\r\n *   CSS string.\r\n */\r\nfunction style(styles) {\r\n  /** @type {Array<string>} */\r\n  const result = []\r\n\r\n  for (const [key, value] of Object.entries(styles)) {\r\n    result.push([key, value].join(': '))\r\n  }\r\n\r\n  return result.join('; ')\r\n}\r\n\r\n/**\r\n * Create a map to adjust casing.\r\n *\r\n * @param {ReadonlyArray<string>} values\r\n *   List of properly cased keys.\r\n * @returns {Map<string, string>}\r\n *   Map of lowercase keys to uppercase keys.\r\n */\r\nfunction createAdjustMap(values) {\r\n  /** @type {Map<string, string>} */\r\n  const result = new Map()\r\n\r\n  for (const value of values) {\r\n    result.set(value.toLowerCase(), value)\r\n  }\r\n\r\n  return result\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}