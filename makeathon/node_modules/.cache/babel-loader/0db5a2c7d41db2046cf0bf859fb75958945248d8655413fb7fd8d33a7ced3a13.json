{"ast":null,"code":"/**\r\n * @typedef {import('unist').Node} UnistNode\r\n * @typedef {import('unist').Parent} UnistParent\r\n */\n\n/**\r\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\r\n *   Test from `unist-util-is`.\r\n *\r\n *   Note: we have remove and add `undefined`, because otherwise when generating\r\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\r\n *   which doesn’t work when publishing on npm.\r\n */\n\n/**\r\n * @typedef {(\r\n *   Fn extends (value: any) => value is infer Thing\r\n *   ? Thing\r\n *   : Fallback\r\n * )} Predicate\r\n *   Get the value of a type guard `Fn`.\r\n * @template Fn\r\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\r\n * @template Fallback\r\n *   Value to yield if `Fn` is not a type guard.\r\n */\n\n/**\r\n * @typedef {(\r\n *   Check extends null | undefined // No test.\r\n *   ? Value\r\n *   : Value extends {type: Check} // String (type) test.\r\n *   ? Value\r\n *   : Value extends Check // Partial test.\r\n *   ? Value\r\n *   : Check extends Function // Function test.\r\n *   ? Predicate<Check, Value> extends Value\r\n *     ? Predicate<Check, Value>\r\n *     : never\r\n *   : never // Some other test?\r\n * )} MatchesOne\r\n *   Check whether a node matches a primitive check in the type system.\r\n * @template Value\r\n *   Value; typically unist `Node`.\r\n * @template Check\r\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\r\n */\n\n/**\r\n * @typedef {(\r\n *   Check extends Array<any>\r\n *   ? MatchesOne<Value, Check[keyof Check]>\r\n *   : MatchesOne<Value, Check>\r\n * )} Matches\r\n *   Check whether a node matches a check in the type system.\r\n * @template Value\r\n *   Value; typically unist `Node`.\r\n * @template Check\r\n *   Value; typically `unist-util-is`-compatible test.\r\n */\n\n/**\r\n * @typedef {(\r\n *   Kind extends {children: Array<infer Child>}\r\n *   ? Child\r\n *   : never\r\n * )} Child\r\n *   Collect nodes that can be parents of `Child`.\r\n * @template {UnistNode} Kind\r\n *   All node types.\r\n */\n\nimport { convert } from 'unist-util-is';\n\n/**\r\n * Find the first node in `parent` after another `node` or after an index,\r\n * that passes `test`.\r\n *\r\n * @param parent\r\n *   Parent node.\r\n * @param index\r\n *   Child node or index.\r\n * @param [test=undefined]\r\n *   Test for child to look for (optional).\r\n * @returns\r\n *   A child (matching `test`, if given) or `undefined`.\r\n */\nexport const findAfter =\n// Note: overloads like this are needed to support optional generics.\n/**\r\n * @type {(\r\n *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &\r\n *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)\r\n * )}\r\n */\n\n/**\r\n * @param {UnistParent} parent\r\n * @param {UnistNode | number} index\r\n * @param {Test} [test]\r\n * @returns {UnistNode | undefined}\r\n */\nfunction (parent, index, test) {\n  const is = convert(test);\n  if (!parent || !parent.type || !parent.children) {\n    throw new Error('Expected parent node');\n  }\n  if (typeof index === 'number') {\n    if (index < 0 || index === Number.POSITIVE_INFINITY) {\n      throw new Error('Expected positive finite number as index');\n    }\n  } else {\n    index = parent.children.indexOf(index);\n    if (index < 0) {\n      throw new Error('Expected child node or index');\n    }\n  }\n  while (++index < parent.children.length) {\n    if (is(parent.children[index], index, parent)) {\n      return parent.children[index];\n    }\n  }\n  return undefined;\n};","map":{"version":3,"names":["convert","findAfter","parent","index","test","is","type","children","Error","Number","POSITIVE_INFINITY","indexOf","length","undefined"],"sources":["C:/Users/smart/Downloads/Final Project P20119/makeathon-2025/makeathon/node_modules/unist-util-find-after/lib/index.js"],"sourcesContent":["/**\r\n * @typedef {import('unist').Node} UnistNode\r\n * @typedef {import('unist').Parent} UnistParent\r\n */\r\n\r\n/**\r\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\r\n *   Test from `unist-util-is`.\r\n *\r\n *   Note: we have remove and add `undefined`, because otherwise when generating\r\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\r\n *   which doesn’t work when publishing on npm.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Fn extends (value: any) => value is infer Thing\r\n *   ? Thing\r\n *   : Fallback\r\n * )} Predicate\r\n *   Get the value of a type guard `Fn`.\r\n * @template Fn\r\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\r\n * @template Fallback\r\n *   Value to yield if `Fn` is not a type guard.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Check extends null | undefined // No test.\r\n *   ? Value\r\n *   : Value extends {type: Check} // String (type) test.\r\n *   ? Value\r\n *   : Value extends Check // Partial test.\r\n *   ? Value\r\n *   : Check extends Function // Function test.\r\n *   ? Predicate<Check, Value> extends Value\r\n *     ? Predicate<Check, Value>\r\n *     : never\r\n *   : never // Some other test?\r\n * )} MatchesOne\r\n *   Check whether a node matches a primitive check in the type system.\r\n * @template Value\r\n *   Value; typically unist `Node`.\r\n * @template Check\r\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Check extends Array<any>\r\n *   ? MatchesOne<Value, Check[keyof Check]>\r\n *   : MatchesOne<Value, Check>\r\n * )} Matches\r\n *   Check whether a node matches a check in the type system.\r\n * @template Value\r\n *   Value; typically unist `Node`.\r\n * @template Check\r\n *   Value; typically `unist-util-is`-compatible test.\r\n */\r\n\r\n/**\r\n * @typedef {(\r\n *   Kind extends {children: Array<infer Child>}\r\n *   ? Child\r\n *   : never\r\n * )} Child\r\n *   Collect nodes that can be parents of `Child`.\r\n * @template {UnistNode} Kind\r\n *   All node types.\r\n */\r\n\r\nimport {convert} from 'unist-util-is'\r\n\r\n/**\r\n * Find the first node in `parent` after another `node` or after an index,\r\n * that passes `test`.\r\n *\r\n * @param parent\r\n *   Parent node.\r\n * @param index\r\n *   Child node or index.\r\n * @param [test=undefined]\r\n *   Test for child to look for (optional).\r\n * @returns\r\n *   A child (matching `test`, if given) or `undefined`.\r\n */\r\nexport const findAfter =\r\n  // Note: overloads like this are needed to support optional generics.\r\n  /**\r\n   * @type {(\r\n   *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &\r\n   *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * @param {UnistParent} parent\r\n     * @param {UnistNode | number} index\r\n     * @param {Test} [test]\r\n     * @returns {UnistNode | undefined}\r\n     */\r\n    function (parent, index, test) {\r\n      const is = convert(test)\r\n\r\n      if (!parent || !parent.type || !parent.children) {\r\n        throw new Error('Expected parent node')\r\n      }\r\n\r\n      if (typeof index === 'number') {\r\n        if (index < 0 || index === Number.POSITIVE_INFINITY) {\r\n          throw new Error('Expected positive finite number as index')\r\n        }\r\n      } else {\r\n        index = parent.children.indexOf(index)\r\n\r\n        if (index < 0) {\r\n          throw new Error('Expected child node or index')\r\n        }\r\n      }\r\n\r\n      while (++index < parent.children.length) {\r\n        if (is(parent.children[index], index, parent)) {\r\n          return parent.children[index]\r\n        }\r\n      }\r\n\r\n      return undefined\r\n    }\r\n  )\r\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,OAAO,QAAO,eAAe;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,SAAS;AACpB;AACA;AACF;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACI,SAAAA,CAAUC,MAAM,EAAEC,KAAK,EAAEC,IAAI,EAAE;EAC7B,MAAMC,EAAE,GAAGL,OAAO,CAACI,IAAI,CAAC;EAExB,IAAI,CAACF,MAAM,IAAI,CAACA,MAAM,CAACI,IAAI,IAAI,CAACJ,MAAM,CAACK,QAAQ,EAAE;IAC/C,MAAM,IAAIC,KAAK,CAAC,sBAAsB,CAAC;EACzC;EAEA,IAAI,OAAOL,KAAK,KAAK,QAAQ,EAAE;IAC7B,IAAIA,KAAK,GAAG,CAAC,IAAIA,KAAK,KAAKM,MAAM,CAACC,iBAAiB,EAAE;MACnD,MAAM,IAAIF,KAAK,CAAC,0CAA0C,CAAC;IAC7D;EACF,CAAC,MAAM;IACLL,KAAK,GAAGD,MAAM,CAACK,QAAQ,CAACI,OAAO,CAACR,KAAK,CAAC;IAEtC,IAAIA,KAAK,GAAG,CAAC,EAAE;MACb,MAAM,IAAIK,KAAK,CAAC,8BAA8B,CAAC;IACjD;EACF;EAEA,OAAO,EAAEL,KAAK,GAAGD,MAAM,CAACK,QAAQ,CAACK,MAAM,EAAE;IACvC,IAAIP,EAAE,CAACH,MAAM,CAACK,QAAQ,CAACJ,KAAK,CAAC,EAAEA,KAAK,EAAED,MAAM,CAAC,EAAE;MAC7C,OAAOA,MAAM,CAACK,QAAQ,CAACJ,KAAK,CAAC;IAC/B;EACF;EAEA,OAAOU,SAAS;AAClB,CACD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}